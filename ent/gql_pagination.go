// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/woocoos/entco/pkg/pagination"
	"github.com/woocoos/msgcenter/ent/msgchannel"
	"github.com/woocoos/msgcenter/ent/msgevent"
	"github.com/woocoos/msgcenter/ent/msgsubscriber"
	"github.com/woocoos/msgcenter/ent/msgtemplate"
	"github.com/woocoos/msgcenter/ent/msgtype"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// MsgChannelEdge is the edge representation of MsgChannel.
type MsgChannelEdge struct {
	Node   *MsgChannel `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// MsgChannelConnection is the connection containing edges to MsgChannel.
type MsgChannelConnection struct {
	Edges      []*MsgChannelEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *MsgChannelConnection) build(nodes []*MsgChannel, pager *msgchannelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MsgChannel
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MsgChannel {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MsgChannel {
			return nodes[i]
		}
	}
	c.Edges = make([]*MsgChannelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MsgChannelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MsgChannelPaginateOption enables pagination customization.
type MsgChannelPaginateOption func(*msgchannelPager) error

// WithMsgChannelOrder configures pagination ordering.
func WithMsgChannelOrder(order *MsgChannelOrder) MsgChannelPaginateOption {
	if order == nil {
		order = DefaultMsgChannelOrder
	}
	o := *order
	return func(pager *msgchannelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMsgChannelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMsgChannelFilter configures pagination filter.
func WithMsgChannelFilter(filter func(*MsgChannelQuery) (*MsgChannelQuery, error)) MsgChannelPaginateOption {
	return func(pager *msgchannelPager) error {
		if filter == nil {
			return errors.New("MsgChannelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type msgchannelPager struct {
	reverse bool
	order   *MsgChannelOrder
	filter  func(*MsgChannelQuery) (*MsgChannelQuery, error)
}

func newMsgChannelPager(opts []MsgChannelPaginateOption, reverse bool) (*msgchannelPager, error) {
	pager := &msgchannelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMsgChannelOrder
	}
	return pager, nil
}

func (p *msgchannelPager) applyFilter(query *MsgChannelQuery) (*MsgChannelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *msgchannelPager) toCursor(mc *MsgChannel) Cursor {
	return p.order.Field.toCursor(mc)
}

func (p *msgchannelPager) applyCursors(query *MsgChannelQuery, after, before *Cursor) (*MsgChannelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMsgChannelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *msgchannelPager) applyOrder(query *MsgChannelQuery) *MsgChannelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMsgChannelOrder.Field {
		query = query.Order(DefaultMsgChannelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *msgchannelPager) orderExpr(query *MsgChannelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMsgChannelOrder.Field {
			b.Comma().Ident(DefaultMsgChannelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MsgChannel.
func (mc *MsgChannelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MsgChannelPaginateOption,
) (*MsgChannelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMsgChannelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mc, err = pager.applyFilter(mc); err != nil {
		return nil, err
	}
	conn := &MsgChannelConnection{Edges: []*MsgChannelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mc, err = pager.applyCursors(mc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mc.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			mc.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			mc.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mc = pager.applyOrder(mc)
	nodes, err := mc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MsgChannelOrderFieldCreatedAt orders MsgChannel by created_at.
	MsgChannelOrderFieldCreatedAt = &MsgChannelOrderField{
		Value: func(mc *MsgChannel) (ent.Value, error) {
			return mc.CreatedAt, nil
		},
		column: msgchannel.FieldCreatedAt,
		toTerm: msgchannel.ByCreatedAt,
		toCursor: func(mc *MsgChannel) Cursor {
			return Cursor{
				ID:    mc.ID,
				Value: mc.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MsgChannelOrderField) String() string {
	var str string
	switch f.column {
	case MsgChannelOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MsgChannelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MsgChannelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MsgChannelOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *MsgChannelOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid MsgChannelOrderField", str)
	}
	return nil
}

// MsgChannelOrderField defines the ordering field of MsgChannel.
type MsgChannelOrderField struct {
	// Value extracts the ordering value from the given MsgChannel.
	Value    func(*MsgChannel) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) msgchannel.OrderOption
	toCursor func(*MsgChannel) Cursor
}

// MsgChannelOrder defines the ordering of MsgChannel.
type MsgChannelOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *MsgChannelOrderField `json:"field"`
}

// DefaultMsgChannelOrder is the default ordering of MsgChannel.
var DefaultMsgChannelOrder = &MsgChannelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MsgChannelOrderField{
		Value: func(mc *MsgChannel) (ent.Value, error) {
			return mc.ID, nil
		},
		column: msgchannel.FieldID,
		toTerm: msgchannel.ByID,
		toCursor: func(mc *MsgChannel) Cursor {
			return Cursor{ID: mc.ID}
		},
	},
}

// ToEdge converts MsgChannel into MsgChannelEdge.
func (mc *MsgChannel) ToEdge(order *MsgChannelOrder) *MsgChannelEdge {
	if order == nil {
		order = DefaultMsgChannelOrder
	}
	return &MsgChannelEdge{
		Node:   mc,
		Cursor: order.Field.toCursor(mc),
	}
}

// MsgEventEdge is the edge representation of MsgEvent.
type MsgEventEdge struct {
	Node   *MsgEvent `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MsgEventConnection is the connection containing edges to MsgEvent.
type MsgEventConnection struct {
	Edges      []*MsgEventEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *MsgEventConnection) build(nodes []*MsgEvent, pager *msgeventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MsgEvent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MsgEvent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MsgEvent {
			return nodes[i]
		}
	}
	c.Edges = make([]*MsgEventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MsgEventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MsgEventPaginateOption enables pagination customization.
type MsgEventPaginateOption func(*msgeventPager) error

// WithMsgEventOrder configures pagination ordering.
func WithMsgEventOrder(order *MsgEventOrder) MsgEventPaginateOption {
	if order == nil {
		order = DefaultMsgEventOrder
	}
	o := *order
	return func(pager *msgeventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMsgEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMsgEventFilter configures pagination filter.
func WithMsgEventFilter(filter func(*MsgEventQuery) (*MsgEventQuery, error)) MsgEventPaginateOption {
	return func(pager *msgeventPager) error {
		if filter == nil {
			return errors.New("MsgEventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type msgeventPager struct {
	reverse bool
	order   *MsgEventOrder
	filter  func(*MsgEventQuery) (*MsgEventQuery, error)
}

func newMsgEventPager(opts []MsgEventPaginateOption, reverse bool) (*msgeventPager, error) {
	pager := &msgeventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMsgEventOrder
	}
	return pager, nil
}

func (p *msgeventPager) applyFilter(query *MsgEventQuery) (*MsgEventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *msgeventPager) toCursor(me *MsgEvent) Cursor {
	return p.order.Field.toCursor(me)
}

func (p *msgeventPager) applyCursors(query *MsgEventQuery, after, before *Cursor) (*MsgEventQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMsgEventOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *msgeventPager) applyOrder(query *MsgEventQuery) *MsgEventQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMsgEventOrder.Field {
		query = query.Order(DefaultMsgEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *msgeventPager) orderExpr(query *MsgEventQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMsgEventOrder.Field {
			b.Comma().Ident(DefaultMsgEventOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MsgEvent.
func (me *MsgEventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MsgEventPaginateOption,
) (*MsgEventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMsgEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if me, err = pager.applyFilter(me); err != nil {
		return nil, err
	}
	conn := &MsgEventConnection{Edges: []*MsgEventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = me.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if me, err = pager.applyCursors(me, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		me.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			me.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			me.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := me.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	me = pager.applyOrder(me)
	nodes, err := me.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MsgEventOrderFieldCreatedAt orders MsgEvent by created_at.
	MsgEventOrderFieldCreatedAt = &MsgEventOrderField{
		Value: func(me *MsgEvent) (ent.Value, error) {
			return me.CreatedAt, nil
		},
		column: msgevent.FieldCreatedAt,
		toTerm: msgevent.ByCreatedAt,
		toCursor: func(me *MsgEvent) Cursor {
			return Cursor{
				ID:    me.ID,
				Value: me.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MsgEventOrderField) String() string {
	var str string
	switch f.column {
	case MsgEventOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MsgEventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MsgEventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MsgEventOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *MsgEventOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid MsgEventOrderField", str)
	}
	return nil
}

// MsgEventOrderField defines the ordering field of MsgEvent.
type MsgEventOrderField struct {
	// Value extracts the ordering value from the given MsgEvent.
	Value    func(*MsgEvent) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) msgevent.OrderOption
	toCursor func(*MsgEvent) Cursor
}

// MsgEventOrder defines the ordering of MsgEvent.
type MsgEventOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MsgEventOrderField `json:"field"`
}

// DefaultMsgEventOrder is the default ordering of MsgEvent.
var DefaultMsgEventOrder = &MsgEventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MsgEventOrderField{
		Value: func(me *MsgEvent) (ent.Value, error) {
			return me.ID, nil
		},
		column: msgevent.FieldID,
		toTerm: msgevent.ByID,
		toCursor: func(me *MsgEvent) Cursor {
			return Cursor{ID: me.ID}
		},
	},
}

// ToEdge converts MsgEvent into MsgEventEdge.
func (me *MsgEvent) ToEdge(order *MsgEventOrder) *MsgEventEdge {
	if order == nil {
		order = DefaultMsgEventOrder
	}
	return &MsgEventEdge{
		Node:   me,
		Cursor: order.Field.toCursor(me),
	}
}

// MsgSubscriberEdge is the edge representation of MsgSubscriber.
type MsgSubscriberEdge struct {
	Node   *MsgSubscriber `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// MsgSubscriberConnection is the connection containing edges to MsgSubscriber.
type MsgSubscriberConnection struct {
	Edges      []*MsgSubscriberEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *MsgSubscriberConnection) build(nodes []*MsgSubscriber, pager *msgsubscriberPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MsgSubscriber
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MsgSubscriber {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MsgSubscriber {
			return nodes[i]
		}
	}
	c.Edges = make([]*MsgSubscriberEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MsgSubscriberEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MsgSubscriberPaginateOption enables pagination customization.
type MsgSubscriberPaginateOption func(*msgsubscriberPager) error

// WithMsgSubscriberOrder configures pagination ordering.
func WithMsgSubscriberOrder(order *MsgSubscriberOrder) MsgSubscriberPaginateOption {
	if order == nil {
		order = DefaultMsgSubscriberOrder
	}
	o := *order
	return func(pager *msgsubscriberPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMsgSubscriberOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMsgSubscriberFilter configures pagination filter.
func WithMsgSubscriberFilter(filter func(*MsgSubscriberQuery) (*MsgSubscriberQuery, error)) MsgSubscriberPaginateOption {
	return func(pager *msgsubscriberPager) error {
		if filter == nil {
			return errors.New("MsgSubscriberQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type msgsubscriberPager struct {
	reverse bool
	order   *MsgSubscriberOrder
	filter  func(*MsgSubscriberQuery) (*MsgSubscriberQuery, error)
}

func newMsgSubscriberPager(opts []MsgSubscriberPaginateOption, reverse bool) (*msgsubscriberPager, error) {
	pager := &msgsubscriberPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMsgSubscriberOrder
	}
	return pager, nil
}

func (p *msgsubscriberPager) applyFilter(query *MsgSubscriberQuery) (*MsgSubscriberQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *msgsubscriberPager) toCursor(ms *MsgSubscriber) Cursor {
	return p.order.Field.toCursor(ms)
}

func (p *msgsubscriberPager) applyCursors(query *MsgSubscriberQuery, after, before *Cursor) (*MsgSubscriberQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMsgSubscriberOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *msgsubscriberPager) applyOrder(query *MsgSubscriberQuery) *MsgSubscriberQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMsgSubscriberOrder.Field {
		query = query.Order(DefaultMsgSubscriberOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *msgsubscriberPager) orderExpr(query *MsgSubscriberQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMsgSubscriberOrder.Field {
			b.Comma().Ident(DefaultMsgSubscriberOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MsgSubscriber.
func (ms *MsgSubscriberQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MsgSubscriberPaginateOption,
) (*MsgSubscriberConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMsgSubscriberPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ms, err = pager.applyFilter(ms); err != nil {
		return nil, err
	}
	conn := &MsgSubscriberConnection{Edges: []*MsgSubscriberEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ms.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ms, err = pager.applyCursors(ms, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ms.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			ms.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ms.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ms.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ms = pager.applyOrder(ms)
	nodes, err := ms.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MsgSubscriberOrderFieldCreatedAt orders MsgSubscriber by created_at.
	MsgSubscriberOrderFieldCreatedAt = &MsgSubscriberOrderField{
		Value: func(ms *MsgSubscriber) (ent.Value, error) {
			return ms.CreatedAt, nil
		},
		column: msgsubscriber.FieldCreatedAt,
		toTerm: msgsubscriber.ByCreatedAt,
		toCursor: func(ms *MsgSubscriber) Cursor {
			return Cursor{
				ID:    ms.ID,
				Value: ms.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MsgSubscriberOrderField) String() string {
	var str string
	switch f.column {
	case MsgSubscriberOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MsgSubscriberOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MsgSubscriberOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MsgSubscriberOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *MsgSubscriberOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid MsgSubscriberOrderField", str)
	}
	return nil
}

// MsgSubscriberOrderField defines the ordering field of MsgSubscriber.
type MsgSubscriberOrderField struct {
	// Value extracts the ordering value from the given MsgSubscriber.
	Value    func(*MsgSubscriber) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) msgsubscriber.OrderOption
	toCursor func(*MsgSubscriber) Cursor
}

// MsgSubscriberOrder defines the ordering of MsgSubscriber.
type MsgSubscriberOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *MsgSubscriberOrderField `json:"field"`
}

// DefaultMsgSubscriberOrder is the default ordering of MsgSubscriber.
var DefaultMsgSubscriberOrder = &MsgSubscriberOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MsgSubscriberOrderField{
		Value: func(ms *MsgSubscriber) (ent.Value, error) {
			return ms.ID, nil
		},
		column: msgsubscriber.FieldID,
		toTerm: msgsubscriber.ByID,
		toCursor: func(ms *MsgSubscriber) Cursor {
			return Cursor{ID: ms.ID}
		},
	},
}

// ToEdge converts MsgSubscriber into MsgSubscriberEdge.
func (ms *MsgSubscriber) ToEdge(order *MsgSubscriberOrder) *MsgSubscriberEdge {
	if order == nil {
		order = DefaultMsgSubscriberOrder
	}
	return &MsgSubscriberEdge{
		Node:   ms,
		Cursor: order.Field.toCursor(ms),
	}
}

// MsgTemplateEdge is the edge representation of MsgTemplate.
type MsgTemplateEdge struct {
	Node   *MsgTemplate `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// MsgTemplateConnection is the connection containing edges to MsgTemplate.
type MsgTemplateConnection struct {
	Edges      []*MsgTemplateEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *MsgTemplateConnection) build(nodes []*MsgTemplate, pager *msgtemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MsgTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MsgTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MsgTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*MsgTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MsgTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MsgTemplatePaginateOption enables pagination customization.
type MsgTemplatePaginateOption func(*msgtemplatePager) error

// WithMsgTemplateOrder configures pagination ordering.
func WithMsgTemplateOrder(order *MsgTemplateOrder) MsgTemplatePaginateOption {
	if order == nil {
		order = DefaultMsgTemplateOrder
	}
	o := *order
	return func(pager *msgtemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMsgTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMsgTemplateFilter configures pagination filter.
func WithMsgTemplateFilter(filter func(*MsgTemplateQuery) (*MsgTemplateQuery, error)) MsgTemplatePaginateOption {
	return func(pager *msgtemplatePager) error {
		if filter == nil {
			return errors.New("MsgTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type msgtemplatePager struct {
	reverse bool
	order   *MsgTemplateOrder
	filter  func(*MsgTemplateQuery) (*MsgTemplateQuery, error)
}

func newMsgTemplatePager(opts []MsgTemplatePaginateOption, reverse bool) (*msgtemplatePager, error) {
	pager := &msgtemplatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMsgTemplateOrder
	}
	return pager, nil
}

func (p *msgtemplatePager) applyFilter(query *MsgTemplateQuery) (*MsgTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *msgtemplatePager) toCursor(mt *MsgTemplate) Cursor {
	return p.order.Field.toCursor(mt)
}

func (p *msgtemplatePager) applyCursors(query *MsgTemplateQuery, after, before *Cursor) (*MsgTemplateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMsgTemplateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *msgtemplatePager) applyOrder(query *MsgTemplateQuery) *MsgTemplateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMsgTemplateOrder.Field {
		query = query.Order(DefaultMsgTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *msgtemplatePager) orderExpr(query *MsgTemplateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMsgTemplateOrder.Field {
			b.Comma().Ident(DefaultMsgTemplateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MsgTemplate.
func (mt *MsgTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MsgTemplatePaginateOption,
) (*MsgTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMsgTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mt, err = pager.applyFilter(mt); err != nil {
		return nil, err
	}
	conn := &MsgTemplateConnection{Edges: []*MsgTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mt, err = pager.applyCursors(mt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mt.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			mt.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			mt.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mt = pager.applyOrder(mt)
	nodes, err := mt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MsgTemplateOrderFieldCreatedAt orders MsgTemplate by created_at.
	MsgTemplateOrderFieldCreatedAt = &MsgTemplateOrderField{
		Value: func(mt *MsgTemplate) (ent.Value, error) {
			return mt.CreatedAt, nil
		},
		column: msgtemplate.FieldCreatedAt,
		toTerm: msgtemplate.ByCreatedAt,
		toCursor: func(mt *MsgTemplate) Cursor {
			return Cursor{
				ID:    mt.ID,
				Value: mt.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MsgTemplateOrderField) String() string {
	var str string
	switch f.column {
	case MsgTemplateOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MsgTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MsgTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MsgTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *MsgTemplateOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid MsgTemplateOrderField", str)
	}
	return nil
}

// MsgTemplateOrderField defines the ordering field of MsgTemplate.
type MsgTemplateOrderField struct {
	// Value extracts the ordering value from the given MsgTemplate.
	Value    func(*MsgTemplate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) msgtemplate.OrderOption
	toCursor func(*MsgTemplate) Cursor
}

// MsgTemplateOrder defines the ordering of MsgTemplate.
type MsgTemplateOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *MsgTemplateOrderField `json:"field"`
}

// DefaultMsgTemplateOrder is the default ordering of MsgTemplate.
var DefaultMsgTemplateOrder = &MsgTemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MsgTemplateOrderField{
		Value: func(mt *MsgTemplate) (ent.Value, error) {
			return mt.ID, nil
		},
		column: msgtemplate.FieldID,
		toTerm: msgtemplate.ByID,
		toCursor: func(mt *MsgTemplate) Cursor {
			return Cursor{ID: mt.ID}
		},
	},
}

// ToEdge converts MsgTemplate into MsgTemplateEdge.
func (mt *MsgTemplate) ToEdge(order *MsgTemplateOrder) *MsgTemplateEdge {
	if order == nil {
		order = DefaultMsgTemplateOrder
	}
	return &MsgTemplateEdge{
		Node:   mt,
		Cursor: order.Field.toCursor(mt),
	}
}

// MsgTypeEdge is the edge representation of MsgType.
type MsgTypeEdge struct {
	Node   *MsgType `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// MsgTypeConnection is the connection containing edges to MsgType.
type MsgTypeConnection struct {
	Edges      []*MsgTypeEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *MsgTypeConnection) build(nodes []*MsgType, pager *msgtypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MsgType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MsgType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MsgType {
			return nodes[i]
		}
	}
	c.Edges = make([]*MsgTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MsgTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MsgTypePaginateOption enables pagination customization.
type MsgTypePaginateOption func(*msgtypePager) error

// WithMsgTypeOrder configures pagination ordering.
func WithMsgTypeOrder(order *MsgTypeOrder) MsgTypePaginateOption {
	if order == nil {
		order = DefaultMsgTypeOrder
	}
	o := *order
	return func(pager *msgtypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMsgTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMsgTypeFilter configures pagination filter.
func WithMsgTypeFilter(filter func(*MsgTypeQuery) (*MsgTypeQuery, error)) MsgTypePaginateOption {
	return func(pager *msgtypePager) error {
		if filter == nil {
			return errors.New("MsgTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type msgtypePager struct {
	reverse bool
	order   *MsgTypeOrder
	filter  func(*MsgTypeQuery) (*MsgTypeQuery, error)
}

func newMsgTypePager(opts []MsgTypePaginateOption, reverse bool) (*msgtypePager, error) {
	pager := &msgtypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMsgTypeOrder
	}
	return pager, nil
}

func (p *msgtypePager) applyFilter(query *MsgTypeQuery) (*MsgTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *msgtypePager) toCursor(mt *MsgType) Cursor {
	return p.order.Field.toCursor(mt)
}

func (p *msgtypePager) applyCursors(query *MsgTypeQuery, after, before *Cursor) (*MsgTypeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMsgTypeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *msgtypePager) applyOrder(query *MsgTypeQuery) *MsgTypeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMsgTypeOrder.Field {
		query = query.Order(DefaultMsgTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *msgtypePager) orderExpr(query *MsgTypeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMsgTypeOrder.Field {
			b.Comma().Ident(DefaultMsgTypeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MsgType.
func (mt *MsgTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MsgTypePaginateOption,
) (*MsgTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMsgTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mt, err = pager.applyFilter(mt); err != nil {
		return nil, err
	}
	conn := &MsgTypeConnection{Edges: []*MsgTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mt, err = pager.applyCursors(mt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mt.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			mt.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			mt.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mt = pager.applyOrder(mt)
	nodes, err := mt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// MsgTypeOrderFieldCreatedAt orders MsgType by created_at.
	MsgTypeOrderFieldCreatedAt = &MsgTypeOrderField{
		Value: func(mt *MsgType) (ent.Value, error) {
			return mt.CreatedAt, nil
		},
		column: msgtype.FieldCreatedAt,
		toTerm: msgtype.ByCreatedAt,
		toCursor: func(mt *MsgType) Cursor {
			return Cursor{
				ID:    mt.ID,
				Value: mt.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MsgTypeOrderField) String() string {
	var str string
	switch f.column {
	case MsgTypeOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MsgTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MsgTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MsgTypeOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *MsgTypeOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid MsgTypeOrderField", str)
	}
	return nil
}

// MsgTypeOrderField defines the ordering field of MsgType.
type MsgTypeOrderField struct {
	// Value extracts the ordering value from the given MsgType.
	Value    func(*MsgType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) msgtype.OrderOption
	toCursor func(*MsgType) Cursor
}

// MsgTypeOrder defines the ordering of MsgType.
type MsgTypeOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *MsgTypeOrderField `json:"field"`
}

// DefaultMsgTypeOrder is the default ordering of MsgType.
var DefaultMsgTypeOrder = &MsgTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MsgTypeOrderField{
		Value: func(mt *MsgType) (ent.Value, error) {
			return mt.ID, nil
		},
		column: msgtype.FieldID,
		toTerm: msgtype.ByID,
		toCursor: func(mt *MsgType) Cursor {
			return Cursor{ID: mt.ID}
		},
	},
}

// ToEdge converts MsgType into MsgTypeEdge.
func (mt *MsgType) ToEdge(order *MsgTypeOrder) *MsgTypeEdge {
	if order == nil {
		order = DefaultMsgTypeOrder
	}
	return &MsgTypeEdge{
		Node:   mt,
		Cursor: order.Field.toCursor(mt),
	}
}
