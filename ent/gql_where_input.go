// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/msgcenter/ent/msgalert"
	"github.com/woocoos/msgcenter/ent/msgchannel"
	"github.com/woocoos/msgcenter/ent/msgevent"
	"github.com/woocoos/msgcenter/ent/msgsubscriber"
	"github.com/woocoos/msgcenter/ent/msgtemplate"
	"github.com/woocoos/msgcenter/ent/msgtype"
	"github.com/woocoos/msgcenter/ent/nlog"
	"github.com/woocoos/msgcenter/ent/nlogalert"
	"github.com/woocoos/msgcenter/ent/predicate"
	"github.com/woocoos/msgcenter/ent/silence"
	"github.com/woocoos/msgcenter/pkg/alert"
	"github.com/woocoos/msgcenter/pkg/profile"
)

// MsgAlertWhereInput represents a where input for filtering MsgAlert queries.
type MsgAlertWhereInput struct {
	Predicates []predicate.MsgAlert  `json:"-"`
	Not        *MsgAlertWhereInput   `json:"not,omitempty"`
	Or         []*MsgAlertWhereInput `json:"or,omitempty"`
	And        []*MsgAlertWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "starts_at" field predicates.
	StartsAt      *time.Time  `json:"startsAt,omitempty"`
	StartsAtNEQ   *time.Time  `json:"startsAtNEQ,omitempty"`
	StartsAtIn    []time.Time `json:"startsAtIn,omitempty"`
	StartsAtNotIn []time.Time `json:"startsAtNotIn,omitempty"`
	StartsAtGT    *time.Time  `json:"startsAtGT,omitempty"`
	StartsAtGTE   *time.Time  `json:"startsAtGTE,omitempty"`
	StartsAtLT    *time.Time  `json:"startsAtLT,omitempty"`
	StartsAtLTE   *time.Time  `json:"startsAtLTE,omitempty"`

	// "ends_at" field predicates.
	EndsAt      *time.Time  `json:"endsAt,omitempty"`
	EndsAtNEQ   *time.Time  `json:"endsAtNEQ,omitempty"`
	EndsAtIn    []time.Time `json:"endsAtIn,omitempty"`
	EndsAtNotIn []time.Time `json:"endsAtNotIn,omitempty"`
	EndsAtGT    *time.Time  `json:"endsAtGT,omitempty"`
	EndsAtGTE   *time.Time  `json:"endsAtGTE,omitempty"`
	EndsAtLT    *time.Time  `json:"endsAtLT,omitempty"`
	EndsAtLTE   *time.Time  `json:"endsAtLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "timeout" field predicates.
	Timeout    *bool `json:"timeout,omitempty"`
	TimeoutNEQ *bool `json:"timeoutNEQ,omitempty"`

	// "fingerprint" field predicates.
	Fingerprint             *string  `json:"fingerprint,omitempty"`
	FingerprintNEQ          *string  `json:"fingerprintNEQ,omitempty"`
	FingerprintIn           []string `json:"fingerprintIn,omitempty"`
	FingerprintNotIn        []string `json:"fingerprintNotIn,omitempty"`
	FingerprintGT           *string  `json:"fingerprintGT,omitempty"`
	FingerprintGTE          *string  `json:"fingerprintGTE,omitempty"`
	FingerprintLT           *string  `json:"fingerprintLT,omitempty"`
	FingerprintLTE          *string  `json:"fingerprintLTE,omitempty"`
	FingerprintContains     *string  `json:"fingerprintContains,omitempty"`
	FingerprintHasPrefix    *string  `json:"fingerprintHasPrefix,omitempty"`
	FingerprintHasSuffix    *string  `json:"fingerprintHasSuffix,omitempty"`
	FingerprintEqualFold    *string  `json:"fingerprintEqualFold,omitempty"`
	FingerprintContainsFold *string  `json:"fingerprintContainsFold,omitempty"`

	// "state" field predicates.
	State      *alert.AlertStatus  `json:"state,omitempty"`
	StateNEQ   *alert.AlertStatus  `json:"stateNEQ,omitempty"`
	StateIn    []alert.AlertStatus `json:"stateIn,omitempty"`
	StateNotIn []alert.AlertStatus `json:"stateNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "deleted" field predicates.
	Deleted    *bool `json:"deleted,omitempty"`
	DeletedNEQ *bool `json:"deletedNEQ,omitempty"`

	// "nlog" edge predicates.
	HasNlog     *bool             `json:"hasNlog,omitempty"`
	HasNlogWith []*NlogWhereInput `json:"hasNlogWith,omitempty"`

	// "nlog_alerts" edge predicates.
	HasNlogAlerts     *bool                  `json:"hasNlogAlerts,omitempty"`
	HasNlogAlertsWith []*NlogAlertWhereInput `json:"hasNlogAlertsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgAlertWhereInput) AddPredicates(predicates ...predicate.MsgAlert) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgAlertWhereInput filter on the MsgAlertQuery builder.
func (i *MsgAlertWhereInput) Filter(q *MsgAlertQuery) (*MsgAlertQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgAlertWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgAlertWhereInput is returned in case the MsgAlertWhereInput is empty.
var ErrEmptyMsgAlertWhereInput = errors.New("ent: empty predicate MsgAlertWhereInput")

// P returns a predicate for filtering msgalerts.
// An error is returned if the input is empty or invalid.
func (i *MsgAlertWhereInput) P() (predicate.MsgAlert, error) {
	var predicates []predicate.MsgAlert
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgalert.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgAlert, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgalert.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgAlert, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgalert.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgalert.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgalert.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgalert.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgalert.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgalert.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgalert.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgalert.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgalert.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgalert.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgalert.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgalert.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgalert.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgalert.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgalert.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgalert.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgalert.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.StartsAt != nil {
		predicates = append(predicates, msgalert.StartsAtEQ(*i.StartsAt))
	}
	if i.StartsAtNEQ != nil {
		predicates = append(predicates, msgalert.StartsAtNEQ(*i.StartsAtNEQ))
	}
	if len(i.StartsAtIn) > 0 {
		predicates = append(predicates, msgalert.StartsAtIn(i.StartsAtIn...))
	}
	if len(i.StartsAtNotIn) > 0 {
		predicates = append(predicates, msgalert.StartsAtNotIn(i.StartsAtNotIn...))
	}
	if i.StartsAtGT != nil {
		predicates = append(predicates, msgalert.StartsAtGT(*i.StartsAtGT))
	}
	if i.StartsAtGTE != nil {
		predicates = append(predicates, msgalert.StartsAtGTE(*i.StartsAtGTE))
	}
	if i.StartsAtLT != nil {
		predicates = append(predicates, msgalert.StartsAtLT(*i.StartsAtLT))
	}
	if i.StartsAtLTE != nil {
		predicates = append(predicates, msgalert.StartsAtLTE(*i.StartsAtLTE))
	}
	if i.EndsAt != nil {
		predicates = append(predicates, msgalert.EndsAtEQ(*i.EndsAt))
	}
	if i.EndsAtNEQ != nil {
		predicates = append(predicates, msgalert.EndsAtNEQ(*i.EndsAtNEQ))
	}
	if len(i.EndsAtIn) > 0 {
		predicates = append(predicates, msgalert.EndsAtIn(i.EndsAtIn...))
	}
	if len(i.EndsAtNotIn) > 0 {
		predicates = append(predicates, msgalert.EndsAtNotIn(i.EndsAtNotIn...))
	}
	if i.EndsAtGT != nil {
		predicates = append(predicates, msgalert.EndsAtGT(*i.EndsAtGT))
	}
	if i.EndsAtGTE != nil {
		predicates = append(predicates, msgalert.EndsAtGTE(*i.EndsAtGTE))
	}
	if i.EndsAtLT != nil {
		predicates = append(predicates, msgalert.EndsAtLT(*i.EndsAtLT))
	}
	if i.EndsAtLTE != nil {
		predicates = append(predicates, msgalert.EndsAtLTE(*i.EndsAtLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, msgalert.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, msgalert.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, msgalert.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, msgalert.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, msgalert.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, msgalert.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, msgalert.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, msgalert.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, msgalert.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, msgalert.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, msgalert.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, msgalert.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, msgalert.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, msgalert.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, msgalert.URLContainsFold(*i.URLContainsFold))
	}
	if i.Timeout != nil {
		predicates = append(predicates, msgalert.TimeoutEQ(*i.Timeout))
	}
	if i.TimeoutNEQ != nil {
		predicates = append(predicates, msgalert.TimeoutNEQ(*i.TimeoutNEQ))
	}
	if i.Fingerprint != nil {
		predicates = append(predicates, msgalert.FingerprintEQ(*i.Fingerprint))
	}
	if i.FingerprintNEQ != nil {
		predicates = append(predicates, msgalert.FingerprintNEQ(*i.FingerprintNEQ))
	}
	if len(i.FingerprintIn) > 0 {
		predicates = append(predicates, msgalert.FingerprintIn(i.FingerprintIn...))
	}
	if len(i.FingerprintNotIn) > 0 {
		predicates = append(predicates, msgalert.FingerprintNotIn(i.FingerprintNotIn...))
	}
	if i.FingerprintGT != nil {
		predicates = append(predicates, msgalert.FingerprintGT(*i.FingerprintGT))
	}
	if i.FingerprintGTE != nil {
		predicates = append(predicates, msgalert.FingerprintGTE(*i.FingerprintGTE))
	}
	if i.FingerprintLT != nil {
		predicates = append(predicates, msgalert.FingerprintLT(*i.FingerprintLT))
	}
	if i.FingerprintLTE != nil {
		predicates = append(predicates, msgalert.FingerprintLTE(*i.FingerprintLTE))
	}
	if i.FingerprintContains != nil {
		predicates = append(predicates, msgalert.FingerprintContains(*i.FingerprintContains))
	}
	if i.FingerprintHasPrefix != nil {
		predicates = append(predicates, msgalert.FingerprintHasPrefix(*i.FingerprintHasPrefix))
	}
	if i.FingerprintHasSuffix != nil {
		predicates = append(predicates, msgalert.FingerprintHasSuffix(*i.FingerprintHasSuffix))
	}
	if i.FingerprintEqualFold != nil {
		predicates = append(predicates, msgalert.FingerprintEqualFold(*i.FingerprintEqualFold))
	}
	if i.FingerprintContainsFold != nil {
		predicates = append(predicates, msgalert.FingerprintContainsFold(*i.FingerprintContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, msgalert.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, msgalert.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, msgalert.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, msgalert.StateNotIn(i.StateNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgalert.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgalert.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgalert.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgalert.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgalert.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgalert.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgalert.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgalert.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgalert.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgalert.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgalert.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgalert.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgalert.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgalert.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgalert.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgalert.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgalert.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgalert.UpdatedAtNotNil())
	}
	if i.Deleted != nil {
		predicates = append(predicates, msgalert.DeletedEQ(*i.Deleted))
	}
	if i.DeletedNEQ != nil {
		predicates = append(predicates, msgalert.DeletedNEQ(*i.DeletedNEQ))
	}

	if i.HasNlog != nil {
		p := msgalert.HasNlog()
		if !*i.HasNlog {
			p = msgalert.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNlogWith) > 0 {
		with := make([]predicate.Nlog, 0, len(i.HasNlogWith))
		for _, w := range i.HasNlogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNlogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgalert.HasNlogWith(with...))
	}
	if i.HasNlogAlerts != nil {
		p := msgalert.HasNlogAlerts()
		if !*i.HasNlogAlerts {
			p = msgalert.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNlogAlertsWith) > 0 {
		with := make([]predicate.NlogAlert, 0, len(i.HasNlogAlertsWith))
		for _, w := range i.HasNlogAlertsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNlogAlertsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgalert.HasNlogAlertsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgAlertWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgalert.And(predicates...), nil
	}
}

// MsgChannelWhereInput represents a where input for filtering MsgChannel queries.
type MsgChannelWhereInput struct {
	Predicates []predicate.MsgChannel  `json:"-"`
	Not        *MsgChannelWhereInput   `json:"not,omitempty"`
	Or         []*MsgChannelWhereInput `json:"or,omitempty"`
	And        []*MsgChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "receiver_type" field predicates.
	ReceiverType      *profile.ReceiverType  `json:"receiverType,omitempty"`
	ReceiverTypeNEQ   *profile.ReceiverType  `json:"receiverTypeNEQ,omitempty"`
	ReceiverTypeIn    []profile.ReceiverType `json:"receiverTypeIn,omitempty"`
	ReceiverTypeNotIn []profile.ReceiverType `json:"receiverTypeNotIn,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsIsNil        bool     `json:"commentsIsNil,omitempty"`
	CommentsNotNil       bool     `json:"commentsNotNil,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgChannelWhereInput) AddPredicates(predicates ...predicate.MsgChannel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgChannelWhereInput filter on the MsgChannelQuery builder.
func (i *MsgChannelWhereInput) Filter(q *MsgChannelQuery) (*MsgChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgChannelWhereInput is returned in case the MsgChannelWhereInput is empty.
var ErrEmptyMsgChannelWhereInput = errors.New("ent: empty predicate MsgChannelWhereInput")

// P returns a predicate for filtering msgchannels.
// An error is returned if the input is empty or invalid.
func (i *MsgChannelWhereInput) P() (predicate.MsgChannel, error) {
	var predicates []predicate.MsgChannel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgchannel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgChannel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgchannel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgChannel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgchannel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgchannel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgchannel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgchannel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgchannel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgchannel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgchannel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgchannel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgchannel.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgchannel.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgchannel.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgchannel.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgchannel.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgchannel.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgchannel.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgchannel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgchannel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgchannel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgchannel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgchannel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgchannel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgchannel.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgchannel.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgchannel.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgchannel.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgchannel.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgchannel.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgchannel.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgchannel.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgchannel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgchannel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgchannel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgchannel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgchannel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgchannel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgchannel.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgchannel.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, msgchannel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgchannel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgchannel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgchannel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgchannel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgchannel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgchannel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgchannel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgchannel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgchannel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgchannel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgchannel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgchannel.NameContainsFold(*i.NameContainsFold))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgchannel.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgchannel.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgchannel.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgchannel.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgchannel.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgchannel.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgchannel.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgchannel.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.ReceiverType != nil {
		predicates = append(predicates, msgchannel.ReceiverTypeEQ(*i.ReceiverType))
	}
	if i.ReceiverTypeNEQ != nil {
		predicates = append(predicates, msgchannel.ReceiverTypeNEQ(*i.ReceiverTypeNEQ))
	}
	if len(i.ReceiverTypeIn) > 0 {
		predicates = append(predicates, msgchannel.ReceiverTypeIn(i.ReceiverTypeIn...))
	}
	if len(i.ReceiverTypeNotIn) > 0 {
		predicates = append(predicates, msgchannel.ReceiverTypeNotIn(i.ReceiverTypeNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, msgchannel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgchannel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgchannel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgchannel.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgchannel.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgchannel.StatusNotNil())
	}
	if i.Comments != nil {
		predicates = append(predicates, msgchannel.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, msgchannel.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, msgchannel.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, msgchannel.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, msgchannel.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, msgchannel.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, msgchannel.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, msgchannel.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, msgchannel.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, msgchannel.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, msgchannel.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsIsNil {
		predicates = append(predicates, msgchannel.CommentsIsNil())
	}
	if i.CommentsNotNil {
		predicates = append(predicates, msgchannel.CommentsNotNil())
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, msgchannel.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, msgchannel.CommentsContainsFold(*i.CommentsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgchannel.And(predicates...), nil
	}
}

// MsgEventWhereInput represents a where input for filtering MsgEvent queries.
type MsgEventWhereInput struct {
	Predicates []predicate.MsgEvent  `json:"-"`
	Not        *MsgEventWhereInput   `json:"not,omitempty"`
	Or         []*MsgEventWhereInput `json:"or,omitempty"`
	And        []*MsgEventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "modes" field predicates.
	Modes             *string  `json:"modes,omitempty"`
	ModesNEQ          *string  `json:"modesNEQ,omitempty"`
	ModesIn           []string `json:"modesIn,omitempty"`
	ModesNotIn        []string `json:"modesNotIn,omitempty"`
	ModesGT           *string  `json:"modesGT,omitempty"`
	ModesGTE          *string  `json:"modesGTE,omitempty"`
	ModesLT           *string  `json:"modesLT,omitempty"`
	ModesLTE          *string  `json:"modesLTE,omitempty"`
	ModesContains     *string  `json:"modesContains,omitempty"`
	ModesHasPrefix    *string  `json:"modesHasPrefix,omitempty"`
	ModesHasSuffix    *string  `json:"modesHasSuffix,omitempty"`
	ModesEqualFold    *string  `json:"modesEqualFold,omitempty"`
	ModesContainsFold *string  `json:"modesContainsFold,omitempty"`

	// "msg_type" edge predicates.
	HasMsgType     *bool                `json:"hasMsgType,omitempty"`
	HasMsgTypeWith []*MsgTypeWhereInput `json:"hasMsgTypeWith,omitempty"`

	// "customer_template" edge predicates.
	HasCustomerTemplate     *bool                    `json:"hasCustomerTemplate,omitempty"`
	HasCustomerTemplateWith []*MsgTemplateWhereInput `json:"hasCustomerTemplateWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgEventWhereInput) AddPredicates(predicates ...predicate.MsgEvent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgEventWhereInput filter on the MsgEventQuery builder.
func (i *MsgEventWhereInput) Filter(q *MsgEventQuery) (*MsgEventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgEventWhereInput is returned in case the MsgEventWhereInput is empty.
var ErrEmptyMsgEventWhereInput = errors.New("ent: empty predicate MsgEventWhereInput")

// P returns a predicate for filtering msgevents.
// An error is returned if the input is empty or invalid.
func (i *MsgEventWhereInput) P() (predicate.MsgEvent, error) {
	var predicates []predicate.MsgEvent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgevent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgEvent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgevent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgEvent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgevent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgevent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgevent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgevent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgevent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgevent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgevent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgevent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgevent.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgevent.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgevent.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgevent.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgevent.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgevent.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgevent.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgevent.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgevent.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgevent.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgevent.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgevent.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgevent.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgevent.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgevent.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgevent.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgevent.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgevent.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgevent.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgevent.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgevent.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgevent.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgevent.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgevent.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgevent.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgevent.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgevent.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgevent.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgevent.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgevent.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgevent.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgevent.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgevent.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgevent.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgevent.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgevent.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgevent.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, msgevent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgevent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgevent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgevent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgevent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgevent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgevent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgevent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgevent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgevent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgevent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgevent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgevent.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgevent.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgevent.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgevent.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgevent.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgevent.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgevent.StatusNotNil())
	}
	if i.Modes != nil {
		predicates = append(predicates, msgevent.ModesEQ(*i.Modes))
	}
	if i.ModesNEQ != nil {
		predicates = append(predicates, msgevent.ModesNEQ(*i.ModesNEQ))
	}
	if len(i.ModesIn) > 0 {
		predicates = append(predicates, msgevent.ModesIn(i.ModesIn...))
	}
	if len(i.ModesNotIn) > 0 {
		predicates = append(predicates, msgevent.ModesNotIn(i.ModesNotIn...))
	}
	if i.ModesGT != nil {
		predicates = append(predicates, msgevent.ModesGT(*i.ModesGT))
	}
	if i.ModesGTE != nil {
		predicates = append(predicates, msgevent.ModesGTE(*i.ModesGTE))
	}
	if i.ModesLT != nil {
		predicates = append(predicates, msgevent.ModesLT(*i.ModesLT))
	}
	if i.ModesLTE != nil {
		predicates = append(predicates, msgevent.ModesLTE(*i.ModesLTE))
	}
	if i.ModesContains != nil {
		predicates = append(predicates, msgevent.ModesContains(*i.ModesContains))
	}
	if i.ModesHasPrefix != nil {
		predicates = append(predicates, msgevent.ModesHasPrefix(*i.ModesHasPrefix))
	}
	if i.ModesHasSuffix != nil {
		predicates = append(predicates, msgevent.ModesHasSuffix(*i.ModesHasSuffix))
	}
	if i.ModesEqualFold != nil {
		predicates = append(predicates, msgevent.ModesEqualFold(*i.ModesEqualFold))
	}
	if i.ModesContainsFold != nil {
		predicates = append(predicates, msgevent.ModesContainsFold(*i.ModesContainsFold))
	}

	if i.HasMsgType != nil {
		p := msgevent.HasMsgType()
		if !*i.HasMsgType {
			p = msgevent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMsgTypeWith) > 0 {
		with := make([]predicate.MsgType, 0, len(i.HasMsgTypeWith))
		for _, w := range i.HasMsgTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMsgTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgevent.HasMsgTypeWith(with...))
	}
	if i.HasCustomerTemplate != nil {
		p := msgevent.HasCustomerTemplate()
		if !*i.HasCustomerTemplate {
			p = msgevent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerTemplateWith) > 0 {
		with := make([]predicate.MsgTemplate, 0, len(i.HasCustomerTemplateWith))
		for _, w := range i.HasCustomerTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgevent.HasCustomerTemplateWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgevent.And(predicates...), nil
	}
}

// MsgSubscriberWhereInput represents a where input for filtering MsgSubscriber queries.
type MsgSubscriberWhereInput struct {
	Predicates []predicate.MsgSubscriber  `json:"-"`
	Not        *MsgSubscriberWhereInput   `json:"not,omitempty"`
	Or         []*MsgSubscriberWhereInput `json:"or,omitempty"`
	And        []*MsgSubscriberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "org_role_id" field predicates.
	OrgRoleID       *int  `json:"orgRoleID,omitempty"`
	OrgRoleIDNEQ    *int  `json:"orgRoleIDNEQ,omitempty"`
	OrgRoleIDIn     []int `json:"orgRoleIDIn,omitempty"`
	OrgRoleIDNotIn  []int `json:"orgRoleIDNotIn,omitempty"`
	OrgRoleIDGT     *int  `json:"orgRoleIDGT,omitempty"`
	OrgRoleIDGTE    *int  `json:"orgRoleIDGTE,omitempty"`
	OrgRoleIDLT     *int  `json:"orgRoleIDLT,omitempty"`
	OrgRoleIDLTE    *int  `json:"orgRoleIDLTE,omitempty"`
	OrgRoleIDIsNil  bool  `json:"orgRoleIDIsNil,omitempty"`
	OrgRoleIDNotNil bool  `json:"orgRoleIDNotNil,omitempty"`

	// "exclude" field predicates.
	Exclude       *bool `json:"exclude,omitempty"`
	ExcludeNEQ    *bool `json:"excludeNEQ,omitempty"`
	ExcludeIsNil  bool  `json:"excludeIsNil,omitempty"`
	ExcludeNotNil bool  `json:"excludeNotNil,omitempty"`

	// "msg_type" edge predicates.
	HasMsgType     *bool                `json:"hasMsgType,omitempty"`
	HasMsgTypeWith []*MsgTypeWhereInput `json:"hasMsgTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgSubscriberWhereInput) AddPredicates(predicates ...predicate.MsgSubscriber) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgSubscriberWhereInput filter on the MsgSubscriberQuery builder.
func (i *MsgSubscriberWhereInput) Filter(q *MsgSubscriberQuery) (*MsgSubscriberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgSubscriberWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgSubscriberWhereInput is returned in case the MsgSubscriberWhereInput is empty.
var ErrEmptyMsgSubscriberWhereInput = errors.New("ent: empty predicate MsgSubscriberWhereInput")

// P returns a predicate for filtering msgsubscribers.
// An error is returned if the input is empty or invalid.
func (i *MsgSubscriberWhereInput) P() (predicate.MsgSubscriber, error) {
	var predicates []predicate.MsgSubscriber
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgsubscriber.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgSubscriber, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgsubscriber.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgSubscriber, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgsubscriber.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgsubscriber.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgsubscriber.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgsubscriber.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgsubscriber.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgsubscriber.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgsubscriber.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgsubscriber.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgsubscriber.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgsubscriber.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgsubscriber.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgsubscriber.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgsubscriber.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgsubscriber.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgsubscriber.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgsubscriber.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgsubscriber.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgsubscriber.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgsubscriber.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgsubscriber.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgsubscriber.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgsubscriber.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, msgsubscriber.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, msgsubscriber.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, msgsubscriber.UserIDNotNil())
	}
	if i.OrgRoleID != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDEQ(*i.OrgRoleID))
	}
	if i.OrgRoleIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNEQ(*i.OrgRoleIDNEQ))
	}
	if len(i.OrgRoleIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.OrgRoleIDIn(i.OrgRoleIDIn...))
	}
	if len(i.OrgRoleIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNotIn(i.OrgRoleIDNotIn...))
	}
	if i.OrgRoleIDGT != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDGT(*i.OrgRoleIDGT))
	}
	if i.OrgRoleIDGTE != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDGTE(*i.OrgRoleIDGTE))
	}
	if i.OrgRoleIDLT != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDLT(*i.OrgRoleIDLT))
	}
	if i.OrgRoleIDLTE != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDLTE(*i.OrgRoleIDLTE))
	}
	if i.OrgRoleIDIsNil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDIsNil())
	}
	if i.OrgRoleIDNotNil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNotNil())
	}
	if i.Exclude != nil {
		predicates = append(predicates, msgsubscriber.ExcludeEQ(*i.Exclude))
	}
	if i.ExcludeNEQ != nil {
		predicates = append(predicates, msgsubscriber.ExcludeNEQ(*i.ExcludeNEQ))
	}
	if i.ExcludeIsNil {
		predicates = append(predicates, msgsubscriber.ExcludeIsNil())
	}
	if i.ExcludeNotNil {
		predicates = append(predicates, msgsubscriber.ExcludeNotNil())
	}

	if i.HasMsgType != nil {
		p := msgsubscriber.HasMsgType()
		if !*i.HasMsgType {
			p = msgsubscriber.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMsgTypeWith) > 0 {
		with := make([]predicate.MsgType, 0, len(i.HasMsgTypeWith))
		for _, w := range i.HasMsgTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMsgTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgsubscriber.HasMsgTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgSubscriberWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgsubscriber.And(predicates...), nil
	}
}

// MsgTemplateWhereInput represents a where input for filtering MsgTemplate queries.
type MsgTemplateWhereInput struct {
	Predicates []predicate.MsgTemplate  `json:"-"`
	Not        *MsgTemplateWhereInput   `json:"not,omitempty"`
	Or         []*MsgTemplateWhereInput `json:"or,omitempty"`
	And        []*MsgTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`
	MsgTypeIDGT    *int  `json:"msgTypeIDGT,omitempty"`
	MsgTypeIDGTE   *int  `json:"msgTypeIDGTE,omitempty"`
	MsgTypeIDLT    *int  `json:"msgTypeIDLT,omitempty"`
	MsgTypeIDLTE   *int  `json:"msgTypeIDLTE,omitempty"`

	// "msg_event_id" field predicates.
	MsgEventID      *int  `json:"msgEventID,omitempty"`
	MsgEventIDNEQ   *int  `json:"msgEventIDNEQ,omitempty"`
	MsgEventIDIn    []int `json:"msgEventIDIn,omitempty"`
	MsgEventIDNotIn []int `json:"msgEventIDNotIn,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "receiver_type" field predicates.
	ReceiverType      *profile.ReceiverType  `json:"receiverType,omitempty"`
	ReceiverTypeNEQ   *profile.ReceiverType  `json:"receiverTypeNEQ,omitempty"`
	ReceiverTypeIn    []profile.ReceiverType `json:"receiverTypeIn,omitempty"`
	ReceiverTypeNotIn []profile.ReceiverType `json:"receiverTypeNotIn,omitempty"`

	// "format" field predicates.
	Format      *msgtemplate.Format  `json:"format,omitempty"`
	FormatNEQ   *msgtemplate.Format  `json:"formatNEQ,omitempty"`
	FormatIn    []msgtemplate.Format `json:"formatIn,omitempty"`
	FormatNotIn []msgtemplate.Format `json:"formatNotIn,omitempty"`

	// "subject" field predicates.
	Subject             *string  `json:"subject,omitempty"`
	SubjectNEQ          *string  `json:"subjectNEQ,omitempty"`
	SubjectIn           []string `json:"subjectIn,omitempty"`
	SubjectNotIn        []string `json:"subjectNotIn,omitempty"`
	SubjectGT           *string  `json:"subjectGT,omitempty"`
	SubjectGTE          *string  `json:"subjectGTE,omitempty"`
	SubjectLT           *string  `json:"subjectLT,omitempty"`
	SubjectLTE          *string  `json:"subjectLTE,omitempty"`
	SubjectContains     *string  `json:"subjectContains,omitempty"`
	SubjectHasPrefix    *string  `json:"subjectHasPrefix,omitempty"`
	SubjectHasSuffix    *string  `json:"subjectHasSuffix,omitempty"`
	SubjectIsNil        bool     `json:"subjectIsNil,omitempty"`
	SubjectNotNil       bool     `json:"subjectNotNil,omitempty"`
	SubjectEqualFold    *string  `json:"subjectEqualFold,omitempty"`
	SubjectContainsFold *string  `json:"subjectContainsFold,omitempty"`

	// "from" field predicates.
	From             *string  `json:"from,omitempty"`
	FromNEQ          *string  `json:"fromNEQ,omitempty"`
	FromIn           []string `json:"fromIn,omitempty"`
	FromNotIn        []string `json:"fromNotIn,omitempty"`
	FromGT           *string  `json:"fromGT,omitempty"`
	FromGTE          *string  `json:"fromGTE,omitempty"`
	FromLT           *string  `json:"fromLT,omitempty"`
	FromLTE          *string  `json:"fromLTE,omitempty"`
	FromContains     *string  `json:"fromContains,omitempty"`
	FromHasPrefix    *string  `json:"fromHasPrefix,omitempty"`
	FromHasSuffix    *string  `json:"fromHasSuffix,omitempty"`
	FromIsNil        bool     `json:"fromIsNil,omitempty"`
	FromNotNil       bool     `json:"fromNotNil,omitempty"`
	FromEqualFold    *string  `json:"fromEqualFold,omitempty"`
	FromContainsFold *string  `json:"fromContainsFold,omitempty"`

	// "to" field predicates.
	To             *string  `json:"to,omitempty"`
	ToNEQ          *string  `json:"toNEQ,omitempty"`
	ToIn           []string `json:"toIn,omitempty"`
	ToNotIn        []string `json:"toNotIn,omitempty"`
	ToGT           *string  `json:"toGT,omitempty"`
	ToGTE          *string  `json:"toGTE,omitempty"`
	ToLT           *string  `json:"toLT,omitempty"`
	ToLTE          *string  `json:"toLTE,omitempty"`
	ToContains     *string  `json:"toContains,omitempty"`
	ToHasPrefix    *string  `json:"toHasPrefix,omitempty"`
	ToHasSuffix    *string  `json:"toHasSuffix,omitempty"`
	ToIsNil        bool     `json:"toIsNil,omitempty"`
	ToNotNil       bool     `json:"toNotNil,omitempty"`
	ToEqualFold    *string  `json:"toEqualFold,omitempty"`
	ToContainsFold *string  `json:"toContainsFold,omitempty"`

	// "cc" field predicates.
	Cc             *string  `json:"cc,omitempty"`
	CcNEQ          *string  `json:"ccNEQ,omitempty"`
	CcIn           []string `json:"ccIn,omitempty"`
	CcNotIn        []string `json:"ccNotIn,omitempty"`
	CcGT           *string  `json:"ccGT,omitempty"`
	CcGTE          *string  `json:"ccGTE,omitempty"`
	CcLT           *string  `json:"ccLT,omitempty"`
	CcLTE          *string  `json:"ccLTE,omitempty"`
	CcContains     *string  `json:"ccContains,omitempty"`
	CcHasPrefix    *string  `json:"ccHasPrefix,omitempty"`
	CcHasSuffix    *string  `json:"ccHasSuffix,omitempty"`
	CcIsNil        bool     `json:"ccIsNil,omitempty"`
	CcNotNil       bool     `json:"ccNotNil,omitempty"`
	CcEqualFold    *string  `json:"ccEqualFold,omitempty"`
	CcContainsFold *string  `json:"ccContainsFold,omitempty"`

	// "bcc" field predicates.
	Bcc             *string  `json:"bcc,omitempty"`
	BccNEQ          *string  `json:"bccNEQ,omitempty"`
	BccIn           []string `json:"bccIn,omitempty"`
	BccNotIn        []string `json:"bccNotIn,omitempty"`
	BccGT           *string  `json:"bccGT,omitempty"`
	BccGTE          *string  `json:"bccGTE,omitempty"`
	BccLT           *string  `json:"bccLT,omitempty"`
	BccLTE          *string  `json:"bccLTE,omitempty"`
	BccContains     *string  `json:"bccContains,omitempty"`
	BccHasPrefix    *string  `json:"bccHasPrefix,omitempty"`
	BccHasSuffix    *string  `json:"bccHasSuffix,omitempty"`
	BccIsNil        bool     `json:"bccIsNil,omitempty"`
	BccNotNil       bool     `json:"bccNotNil,omitempty"`
	BccEqualFold    *string  `json:"bccEqualFold,omitempty"`
	BccContainsFold *string  `json:"bccContainsFold,omitempty"`

	// "event" edge predicates.
	HasEvent     *bool                 `json:"hasEvent,omitempty"`
	HasEventWith []*MsgEventWhereInput `json:"hasEventWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgTemplateWhereInput) AddPredicates(predicates ...predicate.MsgTemplate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgTemplateWhereInput filter on the MsgTemplateQuery builder.
func (i *MsgTemplateWhereInput) Filter(q *MsgTemplateQuery) (*MsgTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgTemplateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgTemplateWhereInput is returned in case the MsgTemplateWhereInput is empty.
var ErrEmptyMsgTemplateWhereInput = errors.New("ent: empty predicate MsgTemplateWhereInput")

// P returns a predicate for filtering msgtemplates.
// An error is returned if the input is empty or invalid.
func (i *MsgTemplateWhereInput) P() (predicate.MsgTemplate, error) {
	var predicates []predicate.MsgTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgtemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgtemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgtemplate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgtemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgtemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgtemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgtemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgtemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgtemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgtemplate.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgtemplate.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgtemplate.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgtemplate.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgtemplate.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgtemplate.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgtemplate.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgtemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgtemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgtemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgtemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgtemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgtemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgtemplate.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgtemplate.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgtemplate.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgtemplate.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgtemplate.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgtemplate.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgtemplate.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgtemplate.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.MsgTypeIDGT != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDGT(*i.MsgTypeIDGT))
	}
	if i.MsgTypeIDGTE != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDGTE(*i.MsgTypeIDGTE))
	}
	if i.MsgTypeIDLT != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDLT(*i.MsgTypeIDLT))
	}
	if i.MsgTypeIDLTE != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDLTE(*i.MsgTypeIDLTE))
	}
	if i.MsgEventID != nil {
		predicates = append(predicates, msgtemplate.MsgEventIDEQ(*i.MsgEventID))
	}
	if i.MsgEventIDNEQ != nil {
		predicates = append(predicates, msgtemplate.MsgEventIDNEQ(*i.MsgEventIDNEQ))
	}
	if len(i.MsgEventIDIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgEventIDIn(i.MsgEventIDIn...))
	}
	if len(i.MsgEventIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgEventIDNotIn(i.MsgEventIDNotIn...))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgtemplate.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgtemplate.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgtemplate.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgtemplate.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgtemplate.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgtemplate.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgtemplate.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, msgtemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgtemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgtemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgtemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgtemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgtemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgtemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgtemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgtemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgtemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgtemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgtemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgtemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgtemplate.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgtemplate.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgtemplate.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgtemplate.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgtemplate.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgtemplate.StatusNotNil())
	}
	if i.ReceiverType != nil {
		predicates = append(predicates, msgtemplate.ReceiverTypeEQ(*i.ReceiverType))
	}
	if i.ReceiverTypeNEQ != nil {
		predicates = append(predicates, msgtemplate.ReceiverTypeNEQ(*i.ReceiverTypeNEQ))
	}
	if len(i.ReceiverTypeIn) > 0 {
		predicates = append(predicates, msgtemplate.ReceiverTypeIn(i.ReceiverTypeIn...))
	}
	if len(i.ReceiverTypeNotIn) > 0 {
		predicates = append(predicates, msgtemplate.ReceiverTypeNotIn(i.ReceiverTypeNotIn...))
	}
	if i.Format != nil {
		predicates = append(predicates, msgtemplate.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, msgtemplate.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, msgtemplate.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, msgtemplate.FormatNotIn(i.FormatNotIn...))
	}
	if i.Subject != nil {
		predicates = append(predicates, msgtemplate.SubjectEQ(*i.Subject))
	}
	if i.SubjectNEQ != nil {
		predicates = append(predicates, msgtemplate.SubjectNEQ(*i.SubjectNEQ))
	}
	if len(i.SubjectIn) > 0 {
		predicates = append(predicates, msgtemplate.SubjectIn(i.SubjectIn...))
	}
	if len(i.SubjectNotIn) > 0 {
		predicates = append(predicates, msgtemplate.SubjectNotIn(i.SubjectNotIn...))
	}
	if i.SubjectGT != nil {
		predicates = append(predicates, msgtemplate.SubjectGT(*i.SubjectGT))
	}
	if i.SubjectGTE != nil {
		predicates = append(predicates, msgtemplate.SubjectGTE(*i.SubjectGTE))
	}
	if i.SubjectLT != nil {
		predicates = append(predicates, msgtemplate.SubjectLT(*i.SubjectLT))
	}
	if i.SubjectLTE != nil {
		predicates = append(predicates, msgtemplate.SubjectLTE(*i.SubjectLTE))
	}
	if i.SubjectContains != nil {
		predicates = append(predicates, msgtemplate.SubjectContains(*i.SubjectContains))
	}
	if i.SubjectHasPrefix != nil {
		predicates = append(predicates, msgtemplate.SubjectHasPrefix(*i.SubjectHasPrefix))
	}
	if i.SubjectHasSuffix != nil {
		predicates = append(predicates, msgtemplate.SubjectHasSuffix(*i.SubjectHasSuffix))
	}
	if i.SubjectIsNil {
		predicates = append(predicates, msgtemplate.SubjectIsNil())
	}
	if i.SubjectNotNil {
		predicates = append(predicates, msgtemplate.SubjectNotNil())
	}
	if i.SubjectEqualFold != nil {
		predicates = append(predicates, msgtemplate.SubjectEqualFold(*i.SubjectEqualFold))
	}
	if i.SubjectContainsFold != nil {
		predicates = append(predicates, msgtemplate.SubjectContainsFold(*i.SubjectContainsFold))
	}
	if i.From != nil {
		predicates = append(predicates, msgtemplate.FromEQ(*i.From))
	}
	if i.FromNEQ != nil {
		predicates = append(predicates, msgtemplate.FromNEQ(*i.FromNEQ))
	}
	if len(i.FromIn) > 0 {
		predicates = append(predicates, msgtemplate.FromIn(i.FromIn...))
	}
	if len(i.FromNotIn) > 0 {
		predicates = append(predicates, msgtemplate.FromNotIn(i.FromNotIn...))
	}
	if i.FromGT != nil {
		predicates = append(predicates, msgtemplate.FromGT(*i.FromGT))
	}
	if i.FromGTE != nil {
		predicates = append(predicates, msgtemplate.FromGTE(*i.FromGTE))
	}
	if i.FromLT != nil {
		predicates = append(predicates, msgtemplate.FromLT(*i.FromLT))
	}
	if i.FromLTE != nil {
		predicates = append(predicates, msgtemplate.FromLTE(*i.FromLTE))
	}
	if i.FromContains != nil {
		predicates = append(predicates, msgtemplate.FromContains(*i.FromContains))
	}
	if i.FromHasPrefix != nil {
		predicates = append(predicates, msgtemplate.FromHasPrefix(*i.FromHasPrefix))
	}
	if i.FromHasSuffix != nil {
		predicates = append(predicates, msgtemplate.FromHasSuffix(*i.FromHasSuffix))
	}
	if i.FromIsNil {
		predicates = append(predicates, msgtemplate.FromIsNil())
	}
	if i.FromNotNil {
		predicates = append(predicates, msgtemplate.FromNotNil())
	}
	if i.FromEqualFold != nil {
		predicates = append(predicates, msgtemplate.FromEqualFold(*i.FromEqualFold))
	}
	if i.FromContainsFold != nil {
		predicates = append(predicates, msgtemplate.FromContainsFold(*i.FromContainsFold))
	}
	if i.To != nil {
		predicates = append(predicates, msgtemplate.ToEQ(*i.To))
	}
	if i.ToNEQ != nil {
		predicates = append(predicates, msgtemplate.ToNEQ(*i.ToNEQ))
	}
	if len(i.ToIn) > 0 {
		predicates = append(predicates, msgtemplate.ToIn(i.ToIn...))
	}
	if len(i.ToNotIn) > 0 {
		predicates = append(predicates, msgtemplate.ToNotIn(i.ToNotIn...))
	}
	if i.ToGT != nil {
		predicates = append(predicates, msgtemplate.ToGT(*i.ToGT))
	}
	if i.ToGTE != nil {
		predicates = append(predicates, msgtemplate.ToGTE(*i.ToGTE))
	}
	if i.ToLT != nil {
		predicates = append(predicates, msgtemplate.ToLT(*i.ToLT))
	}
	if i.ToLTE != nil {
		predicates = append(predicates, msgtemplate.ToLTE(*i.ToLTE))
	}
	if i.ToContains != nil {
		predicates = append(predicates, msgtemplate.ToContains(*i.ToContains))
	}
	if i.ToHasPrefix != nil {
		predicates = append(predicates, msgtemplate.ToHasPrefix(*i.ToHasPrefix))
	}
	if i.ToHasSuffix != nil {
		predicates = append(predicates, msgtemplate.ToHasSuffix(*i.ToHasSuffix))
	}
	if i.ToIsNil {
		predicates = append(predicates, msgtemplate.ToIsNil())
	}
	if i.ToNotNil {
		predicates = append(predicates, msgtemplate.ToNotNil())
	}
	if i.ToEqualFold != nil {
		predicates = append(predicates, msgtemplate.ToEqualFold(*i.ToEqualFold))
	}
	if i.ToContainsFold != nil {
		predicates = append(predicates, msgtemplate.ToContainsFold(*i.ToContainsFold))
	}
	if i.Cc != nil {
		predicates = append(predicates, msgtemplate.CcEQ(*i.Cc))
	}
	if i.CcNEQ != nil {
		predicates = append(predicates, msgtemplate.CcNEQ(*i.CcNEQ))
	}
	if len(i.CcIn) > 0 {
		predicates = append(predicates, msgtemplate.CcIn(i.CcIn...))
	}
	if len(i.CcNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CcNotIn(i.CcNotIn...))
	}
	if i.CcGT != nil {
		predicates = append(predicates, msgtemplate.CcGT(*i.CcGT))
	}
	if i.CcGTE != nil {
		predicates = append(predicates, msgtemplate.CcGTE(*i.CcGTE))
	}
	if i.CcLT != nil {
		predicates = append(predicates, msgtemplate.CcLT(*i.CcLT))
	}
	if i.CcLTE != nil {
		predicates = append(predicates, msgtemplate.CcLTE(*i.CcLTE))
	}
	if i.CcContains != nil {
		predicates = append(predicates, msgtemplate.CcContains(*i.CcContains))
	}
	if i.CcHasPrefix != nil {
		predicates = append(predicates, msgtemplate.CcHasPrefix(*i.CcHasPrefix))
	}
	if i.CcHasSuffix != nil {
		predicates = append(predicates, msgtemplate.CcHasSuffix(*i.CcHasSuffix))
	}
	if i.CcIsNil {
		predicates = append(predicates, msgtemplate.CcIsNil())
	}
	if i.CcNotNil {
		predicates = append(predicates, msgtemplate.CcNotNil())
	}
	if i.CcEqualFold != nil {
		predicates = append(predicates, msgtemplate.CcEqualFold(*i.CcEqualFold))
	}
	if i.CcContainsFold != nil {
		predicates = append(predicates, msgtemplate.CcContainsFold(*i.CcContainsFold))
	}
	if i.Bcc != nil {
		predicates = append(predicates, msgtemplate.BccEQ(*i.Bcc))
	}
	if i.BccNEQ != nil {
		predicates = append(predicates, msgtemplate.BccNEQ(*i.BccNEQ))
	}
	if len(i.BccIn) > 0 {
		predicates = append(predicates, msgtemplate.BccIn(i.BccIn...))
	}
	if len(i.BccNotIn) > 0 {
		predicates = append(predicates, msgtemplate.BccNotIn(i.BccNotIn...))
	}
	if i.BccGT != nil {
		predicates = append(predicates, msgtemplate.BccGT(*i.BccGT))
	}
	if i.BccGTE != nil {
		predicates = append(predicates, msgtemplate.BccGTE(*i.BccGTE))
	}
	if i.BccLT != nil {
		predicates = append(predicates, msgtemplate.BccLT(*i.BccLT))
	}
	if i.BccLTE != nil {
		predicates = append(predicates, msgtemplate.BccLTE(*i.BccLTE))
	}
	if i.BccContains != nil {
		predicates = append(predicates, msgtemplate.BccContains(*i.BccContains))
	}
	if i.BccHasPrefix != nil {
		predicates = append(predicates, msgtemplate.BccHasPrefix(*i.BccHasPrefix))
	}
	if i.BccHasSuffix != nil {
		predicates = append(predicates, msgtemplate.BccHasSuffix(*i.BccHasSuffix))
	}
	if i.BccIsNil {
		predicates = append(predicates, msgtemplate.BccIsNil())
	}
	if i.BccNotNil {
		predicates = append(predicates, msgtemplate.BccNotNil())
	}
	if i.BccEqualFold != nil {
		predicates = append(predicates, msgtemplate.BccEqualFold(*i.BccEqualFold))
	}
	if i.BccContainsFold != nil {
		predicates = append(predicates, msgtemplate.BccContainsFold(*i.BccContainsFold))
	}

	if i.HasEvent != nil {
		p := msgtemplate.HasEvent()
		if !*i.HasEvent {
			p = msgtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventWith) > 0 {
		with := make([]predicate.MsgEvent, 0, len(i.HasEventWith))
		for _, w := range i.HasEventWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtemplate.HasEventWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgTemplateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgtemplate.And(predicates...), nil
	}
}

// MsgTypeWhereInput represents a where input for filtering MsgType queries.
type MsgTypeWhereInput struct {
	Predicates []predicate.MsgType  `json:"-"`
	Not        *MsgTypeWhereInput   `json:"not,omitempty"`
	Or         []*MsgTypeWhereInput `json:"or,omitempty"`
	And        []*MsgTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID       *int  `json:"appID,omitempty"`
	AppIDNEQ    *int  `json:"appIDNEQ,omitempty"`
	AppIDIn     []int `json:"appIDIn,omitempty"`
	AppIDNotIn  []int `json:"appIDNotIn,omitempty"`
	AppIDGT     *int  `json:"appIDGT,omitempty"`
	AppIDGTE    *int  `json:"appIDGTE,omitempty"`
	AppIDLT     *int  `json:"appIDLT,omitempty"`
	AppIDLTE    *int  `json:"appIDLTE,omitempty"`
	AppIDIsNil  bool  `json:"appIDIsNil,omitempty"`
	AppIDNotNil bool  `json:"appIDNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "can_subs" field predicates.
	CanSubs       *bool `json:"canSubs,omitempty"`
	CanSubsNEQ    *bool `json:"canSubsNEQ,omitempty"`
	CanSubsIsNil  bool  `json:"canSubsIsNil,omitempty"`
	CanSubsNotNil bool  `json:"canSubsNotNil,omitempty"`

	// "can_custom" field predicates.
	CanCustom       *bool `json:"canCustom,omitempty"`
	CanCustomNEQ    *bool `json:"canCustomNEQ,omitempty"`
	CanCustomIsNil  bool  `json:"canCustomIsNil,omitempty"`
	CanCustomNotNil bool  `json:"canCustomNotNil,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool                 `json:"hasEvents,omitempty"`
	HasEventsWith []*MsgEventWhereInput `json:"hasEventsWith,omitempty"`

	// "subscribers" edge predicates.
	HasSubscribers     *bool                      `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*MsgSubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgTypeWhereInput) AddPredicates(predicates ...predicate.MsgType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgTypeWhereInput filter on the MsgTypeQuery builder.
func (i *MsgTypeWhereInput) Filter(q *MsgTypeQuery) (*MsgTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgTypeWhereInput is returned in case the MsgTypeWhereInput is empty.
var ErrEmptyMsgTypeWhereInput = errors.New("ent: empty predicate MsgTypeWhereInput")

// P returns a predicate for filtering msgtypes.
// An error is returned if the input is empty or invalid.
func (i *MsgTypeWhereInput) P() (predicate.MsgType, error) {
	var predicates []predicate.MsgType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgtype.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgtype.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgtype.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgtype.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgtype.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgtype.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgtype.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgtype.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgtype.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgtype.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgtype.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgtype.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgtype.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgtype.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgtype.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgtype.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgtype.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgtype.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, msgtype.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, msgtype.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, msgtype.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, msgtype.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, msgtype.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, msgtype.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, msgtype.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, msgtype.AppIDLTE(*i.AppIDLTE))
	}
	if i.AppIDIsNil {
		predicates = append(predicates, msgtype.AppIDIsNil())
	}
	if i.AppIDNotNil {
		predicates = append(predicates, msgtype.AppIDNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, msgtype.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, msgtype.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, msgtype.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, msgtype.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, msgtype.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, msgtype.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, msgtype.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, msgtype.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, msgtype.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, msgtype.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, msgtype.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, msgtype.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, msgtype.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, msgtype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgtype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgtype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgtype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgtype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgtype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgtype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgtype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgtype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgtype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgtype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgtype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgtype.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgtype.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgtype.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgtype.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgtype.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgtype.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgtype.StatusNotNil())
	}
	if i.CanSubs != nil {
		predicates = append(predicates, msgtype.CanSubsEQ(*i.CanSubs))
	}
	if i.CanSubsNEQ != nil {
		predicates = append(predicates, msgtype.CanSubsNEQ(*i.CanSubsNEQ))
	}
	if i.CanSubsIsNil {
		predicates = append(predicates, msgtype.CanSubsIsNil())
	}
	if i.CanSubsNotNil {
		predicates = append(predicates, msgtype.CanSubsNotNil())
	}
	if i.CanCustom != nil {
		predicates = append(predicates, msgtype.CanCustomEQ(*i.CanCustom))
	}
	if i.CanCustomNEQ != nil {
		predicates = append(predicates, msgtype.CanCustomNEQ(*i.CanCustomNEQ))
	}
	if i.CanCustomIsNil {
		predicates = append(predicates, msgtype.CanCustomIsNil())
	}
	if i.CanCustomNotNil {
		predicates = append(predicates, msgtype.CanCustomNotNil())
	}

	if i.HasEvents != nil {
		p := msgtype.HasEvents()
		if !*i.HasEvents {
			p = msgtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.MsgEvent, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtype.HasEventsWith(with...))
	}
	if i.HasSubscribers != nil {
		p := msgtype.HasSubscribers()
		if !*i.HasSubscribers {
			p = msgtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscribersWith) > 0 {
		with := make([]predicate.MsgSubscriber, 0, len(i.HasSubscribersWith))
		for _, w := range i.HasSubscribersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscribersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtype.HasSubscribersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgtype.And(predicates...), nil
	}
}

// NlogWhereInput represents a where input for filtering Nlog queries.
type NlogWhereInput struct {
	Predicates []predicate.Nlog  `json:"-"`
	Not        *NlogWhereInput   `json:"not,omitempty"`
	Or         []*NlogWhereInput `json:"or,omitempty"`
	And        []*NlogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "group_key" field predicates.
	GroupKey             *string  `json:"groupKey,omitempty"`
	GroupKeyNEQ          *string  `json:"groupKeyNEQ,omitempty"`
	GroupKeyIn           []string `json:"groupKeyIn,omitempty"`
	GroupKeyNotIn        []string `json:"groupKeyNotIn,omitempty"`
	GroupKeyGT           *string  `json:"groupKeyGT,omitempty"`
	GroupKeyGTE          *string  `json:"groupKeyGTE,omitempty"`
	GroupKeyLT           *string  `json:"groupKeyLT,omitempty"`
	GroupKeyLTE          *string  `json:"groupKeyLTE,omitempty"`
	GroupKeyContains     *string  `json:"groupKeyContains,omitempty"`
	GroupKeyHasPrefix    *string  `json:"groupKeyHasPrefix,omitempty"`
	GroupKeyHasSuffix    *string  `json:"groupKeyHasSuffix,omitempty"`
	GroupKeyEqualFold    *string  `json:"groupKeyEqualFold,omitempty"`
	GroupKeyContainsFold *string  `json:"groupKeyContainsFold,omitempty"`

	// "receiver" field predicates.
	Receiver             *string  `json:"receiver,omitempty"`
	ReceiverNEQ          *string  `json:"receiverNEQ,omitempty"`
	ReceiverIn           []string `json:"receiverIn,omitempty"`
	ReceiverNotIn        []string `json:"receiverNotIn,omitempty"`
	ReceiverGT           *string  `json:"receiverGT,omitempty"`
	ReceiverGTE          *string  `json:"receiverGTE,omitempty"`
	ReceiverLT           *string  `json:"receiverLT,omitempty"`
	ReceiverLTE          *string  `json:"receiverLTE,omitempty"`
	ReceiverContains     *string  `json:"receiverContains,omitempty"`
	ReceiverHasPrefix    *string  `json:"receiverHasPrefix,omitempty"`
	ReceiverHasSuffix    *string  `json:"receiverHasSuffix,omitempty"`
	ReceiverEqualFold    *string  `json:"receiverEqualFold,omitempty"`
	ReceiverContainsFold *string  `json:"receiverContainsFold,omitempty"`

	// "receiver_type" field predicates.
	ReceiverType      *profile.ReceiverType  `json:"receiverType,omitempty"`
	ReceiverTypeNEQ   *profile.ReceiverType  `json:"receiverTypeNEQ,omitempty"`
	ReceiverTypeIn    []profile.ReceiverType `json:"receiverTypeIn,omitempty"`
	ReceiverTypeNotIn []profile.ReceiverType `json:"receiverTypeNotIn,omitempty"`

	// "idx" field predicates.
	Idx      *int  `json:"idx,omitempty"`
	IdxNEQ   *int  `json:"idxNEQ,omitempty"`
	IdxIn    []int `json:"idxIn,omitempty"`
	IdxNotIn []int `json:"idxNotIn,omitempty"`
	IdxGT    *int  `json:"idxGT,omitempty"`
	IdxGTE   *int  `json:"idxGTE,omitempty"`
	IdxLT    *int  `json:"idxLT,omitempty"`
	IdxLTE   *int  `json:"idxLTE,omitempty"`

	// "send_at" field predicates.
	SendAt      *time.Time  `json:"sendAt,omitempty"`
	SendAtNEQ   *time.Time  `json:"sendAtNEQ,omitempty"`
	SendAtIn    []time.Time `json:"sendAtIn,omitempty"`
	SendAtNotIn []time.Time `json:"sendAtNotIn,omitempty"`
	SendAtGT    *time.Time  `json:"sendAtGT,omitempty"`
	SendAtGTE   *time.Time  `json:"sendAtGTE,omitempty"`
	SendAtLT    *time.Time  `json:"sendAtLT,omitempty"`
	SendAtLTE   *time.Time  `json:"sendAtLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt      *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresAtLTE,omitempty"`

	// "alerts" edge predicates.
	HasAlerts     *bool                 `json:"hasAlerts,omitempty"`
	HasAlertsWith []*MsgAlertWhereInput `json:"hasAlertsWith,omitempty"`

	// "nlog_alert" edge predicates.
	HasNlogAlert     *bool                  `json:"hasNlogAlert,omitempty"`
	HasNlogAlertWith []*NlogAlertWhereInput `json:"hasNlogAlertWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NlogWhereInput) AddPredicates(predicates ...predicate.Nlog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NlogWhereInput filter on the NlogQuery builder.
func (i *NlogWhereInput) Filter(q *NlogQuery) (*NlogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNlogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNlogWhereInput is returned in case the NlogWhereInput is empty.
var ErrEmptyNlogWhereInput = errors.New("ent: empty predicate NlogWhereInput")

// P returns a predicate for filtering nlogs.
// An error is returned if the input is empty or invalid.
func (i *NlogWhereInput) P() (predicate.Nlog, error) {
	var predicates []predicate.Nlog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, nlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Nlog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, nlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Nlog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, nlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, nlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, nlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, nlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, nlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, nlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, nlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, nlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, nlog.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, nlog.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, nlog.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, nlog.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, nlog.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, nlog.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, nlog.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, nlog.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, nlog.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.GroupKey != nil {
		predicates = append(predicates, nlog.GroupKeyEQ(*i.GroupKey))
	}
	if i.GroupKeyNEQ != nil {
		predicates = append(predicates, nlog.GroupKeyNEQ(*i.GroupKeyNEQ))
	}
	if len(i.GroupKeyIn) > 0 {
		predicates = append(predicates, nlog.GroupKeyIn(i.GroupKeyIn...))
	}
	if len(i.GroupKeyNotIn) > 0 {
		predicates = append(predicates, nlog.GroupKeyNotIn(i.GroupKeyNotIn...))
	}
	if i.GroupKeyGT != nil {
		predicates = append(predicates, nlog.GroupKeyGT(*i.GroupKeyGT))
	}
	if i.GroupKeyGTE != nil {
		predicates = append(predicates, nlog.GroupKeyGTE(*i.GroupKeyGTE))
	}
	if i.GroupKeyLT != nil {
		predicates = append(predicates, nlog.GroupKeyLT(*i.GroupKeyLT))
	}
	if i.GroupKeyLTE != nil {
		predicates = append(predicates, nlog.GroupKeyLTE(*i.GroupKeyLTE))
	}
	if i.GroupKeyContains != nil {
		predicates = append(predicates, nlog.GroupKeyContains(*i.GroupKeyContains))
	}
	if i.GroupKeyHasPrefix != nil {
		predicates = append(predicates, nlog.GroupKeyHasPrefix(*i.GroupKeyHasPrefix))
	}
	if i.GroupKeyHasSuffix != nil {
		predicates = append(predicates, nlog.GroupKeyHasSuffix(*i.GroupKeyHasSuffix))
	}
	if i.GroupKeyEqualFold != nil {
		predicates = append(predicates, nlog.GroupKeyEqualFold(*i.GroupKeyEqualFold))
	}
	if i.GroupKeyContainsFold != nil {
		predicates = append(predicates, nlog.GroupKeyContainsFold(*i.GroupKeyContainsFold))
	}
	if i.Receiver != nil {
		predicates = append(predicates, nlog.ReceiverEQ(*i.Receiver))
	}
	if i.ReceiverNEQ != nil {
		predicates = append(predicates, nlog.ReceiverNEQ(*i.ReceiverNEQ))
	}
	if len(i.ReceiverIn) > 0 {
		predicates = append(predicates, nlog.ReceiverIn(i.ReceiverIn...))
	}
	if len(i.ReceiverNotIn) > 0 {
		predicates = append(predicates, nlog.ReceiverNotIn(i.ReceiverNotIn...))
	}
	if i.ReceiverGT != nil {
		predicates = append(predicates, nlog.ReceiverGT(*i.ReceiverGT))
	}
	if i.ReceiverGTE != nil {
		predicates = append(predicates, nlog.ReceiverGTE(*i.ReceiverGTE))
	}
	if i.ReceiverLT != nil {
		predicates = append(predicates, nlog.ReceiverLT(*i.ReceiverLT))
	}
	if i.ReceiverLTE != nil {
		predicates = append(predicates, nlog.ReceiverLTE(*i.ReceiverLTE))
	}
	if i.ReceiverContains != nil {
		predicates = append(predicates, nlog.ReceiverContains(*i.ReceiverContains))
	}
	if i.ReceiverHasPrefix != nil {
		predicates = append(predicates, nlog.ReceiverHasPrefix(*i.ReceiverHasPrefix))
	}
	if i.ReceiverHasSuffix != nil {
		predicates = append(predicates, nlog.ReceiverHasSuffix(*i.ReceiverHasSuffix))
	}
	if i.ReceiverEqualFold != nil {
		predicates = append(predicates, nlog.ReceiverEqualFold(*i.ReceiverEqualFold))
	}
	if i.ReceiverContainsFold != nil {
		predicates = append(predicates, nlog.ReceiverContainsFold(*i.ReceiverContainsFold))
	}
	if i.ReceiverType != nil {
		predicates = append(predicates, nlog.ReceiverTypeEQ(*i.ReceiverType))
	}
	if i.ReceiverTypeNEQ != nil {
		predicates = append(predicates, nlog.ReceiverTypeNEQ(*i.ReceiverTypeNEQ))
	}
	if len(i.ReceiverTypeIn) > 0 {
		predicates = append(predicates, nlog.ReceiverTypeIn(i.ReceiverTypeIn...))
	}
	if len(i.ReceiverTypeNotIn) > 0 {
		predicates = append(predicates, nlog.ReceiverTypeNotIn(i.ReceiverTypeNotIn...))
	}
	if i.Idx != nil {
		predicates = append(predicates, nlog.IdxEQ(*i.Idx))
	}
	if i.IdxNEQ != nil {
		predicates = append(predicates, nlog.IdxNEQ(*i.IdxNEQ))
	}
	if len(i.IdxIn) > 0 {
		predicates = append(predicates, nlog.IdxIn(i.IdxIn...))
	}
	if len(i.IdxNotIn) > 0 {
		predicates = append(predicates, nlog.IdxNotIn(i.IdxNotIn...))
	}
	if i.IdxGT != nil {
		predicates = append(predicates, nlog.IdxGT(*i.IdxGT))
	}
	if i.IdxGTE != nil {
		predicates = append(predicates, nlog.IdxGTE(*i.IdxGTE))
	}
	if i.IdxLT != nil {
		predicates = append(predicates, nlog.IdxLT(*i.IdxLT))
	}
	if i.IdxLTE != nil {
		predicates = append(predicates, nlog.IdxLTE(*i.IdxLTE))
	}
	if i.SendAt != nil {
		predicates = append(predicates, nlog.SendAtEQ(*i.SendAt))
	}
	if i.SendAtNEQ != nil {
		predicates = append(predicates, nlog.SendAtNEQ(*i.SendAtNEQ))
	}
	if len(i.SendAtIn) > 0 {
		predicates = append(predicates, nlog.SendAtIn(i.SendAtIn...))
	}
	if len(i.SendAtNotIn) > 0 {
		predicates = append(predicates, nlog.SendAtNotIn(i.SendAtNotIn...))
	}
	if i.SendAtGT != nil {
		predicates = append(predicates, nlog.SendAtGT(*i.SendAtGT))
	}
	if i.SendAtGTE != nil {
		predicates = append(predicates, nlog.SendAtGTE(*i.SendAtGTE))
	}
	if i.SendAtLT != nil {
		predicates = append(predicates, nlog.SendAtLT(*i.SendAtLT))
	}
	if i.SendAtLTE != nil {
		predicates = append(predicates, nlog.SendAtLTE(*i.SendAtLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, nlog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, nlog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, nlog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, nlog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, nlog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, nlog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, nlog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, nlog.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, nlog.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, nlog.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, nlog.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, nlog.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, nlog.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, nlog.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, nlog.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, nlog.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, nlog.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, nlog.UpdatedAtNotNil())
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, nlog.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, nlog.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, nlog.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, nlog.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, nlog.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, nlog.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, nlog.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, nlog.ExpiresAtLTE(*i.ExpiresAtLTE))
	}

	if i.HasAlerts != nil {
		p := nlog.HasAlerts()
		if !*i.HasAlerts {
			p = nlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAlertsWith) > 0 {
		with := make([]predicate.MsgAlert, 0, len(i.HasAlertsWith))
		for _, w := range i.HasAlertsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAlertsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, nlog.HasAlertsWith(with...))
	}
	if i.HasNlogAlert != nil {
		p := nlog.HasNlogAlert()
		if !*i.HasNlogAlert {
			p = nlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNlogAlertWith) > 0 {
		with := make([]predicate.NlogAlert, 0, len(i.HasNlogAlertWith))
		for _, w := range i.HasNlogAlertWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNlogAlertWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, nlog.HasNlogAlertWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNlogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return nlog.And(predicates...), nil
	}
}

// NlogAlertWhereInput represents a where input for filtering NlogAlert queries.
type NlogAlertWhereInput struct {
	Predicates []predicate.NlogAlert  `json:"-"`
	Not        *NlogAlertWhereInput   `json:"not,omitempty"`
	Or         []*NlogAlertWhereInput `json:"or,omitempty"`
	And        []*NlogAlertWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "nlog_id" field predicates.
	NlogID      *int  `json:"nlogID,omitempty"`
	NlogIDNEQ   *int  `json:"nlogIDNEQ,omitempty"`
	NlogIDIn    []int `json:"nlogIDIn,omitempty"`
	NlogIDNotIn []int `json:"nlogIDNotIn,omitempty"`

	// "alert_id" field predicates.
	AlertID      *int  `json:"alertID,omitempty"`
	AlertIDNEQ   *int  `json:"alertIDNEQ,omitempty"`
	AlertIDIn    []int `json:"alertIDIn,omitempty"`
	AlertIDNotIn []int `json:"alertIDNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "nlog" edge predicates.
	HasNlog     *bool             `json:"hasNlog,omitempty"`
	HasNlogWith []*NlogWhereInput `json:"hasNlogWith,omitempty"`

	// "alert" edge predicates.
	HasAlert     *bool                 `json:"hasAlert,omitempty"`
	HasAlertWith []*MsgAlertWhereInput `json:"hasAlertWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NlogAlertWhereInput) AddPredicates(predicates ...predicate.NlogAlert) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NlogAlertWhereInput filter on the NlogAlertQuery builder.
func (i *NlogAlertWhereInput) Filter(q *NlogAlertQuery) (*NlogAlertQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNlogAlertWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNlogAlertWhereInput is returned in case the NlogAlertWhereInput is empty.
var ErrEmptyNlogAlertWhereInput = errors.New("ent: empty predicate NlogAlertWhereInput")

// P returns a predicate for filtering nlogalerts.
// An error is returned if the input is empty or invalid.
func (i *NlogAlertWhereInput) P() (predicate.NlogAlert, error) {
	var predicates []predicate.NlogAlert
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, nlogalert.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.NlogAlert, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, nlogalert.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.NlogAlert, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, nlogalert.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, nlogalert.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, nlogalert.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, nlogalert.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, nlogalert.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, nlogalert.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, nlogalert.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, nlogalert.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, nlogalert.IDLTE(*i.IDLTE))
	}
	if i.NlogID != nil {
		predicates = append(predicates, nlogalert.NlogIDEQ(*i.NlogID))
	}
	if i.NlogIDNEQ != nil {
		predicates = append(predicates, nlogalert.NlogIDNEQ(*i.NlogIDNEQ))
	}
	if len(i.NlogIDIn) > 0 {
		predicates = append(predicates, nlogalert.NlogIDIn(i.NlogIDIn...))
	}
	if len(i.NlogIDNotIn) > 0 {
		predicates = append(predicates, nlogalert.NlogIDNotIn(i.NlogIDNotIn...))
	}
	if i.AlertID != nil {
		predicates = append(predicates, nlogalert.AlertIDEQ(*i.AlertID))
	}
	if i.AlertIDNEQ != nil {
		predicates = append(predicates, nlogalert.AlertIDNEQ(*i.AlertIDNEQ))
	}
	if len(i.AlertIDIn) > 0 {
		predicates = append(predicates, nlogalert.AlertIDIn(i.AlertIDIn...))
	}
	if len(i.AlertIDNotIn) > 0 {
		predicates = append(predicates, nlogalert.AlertIDNotIn(i.AlertIDNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, nlogalert.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, nlogalert.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, nlogalert.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, nlogalert.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, nlogalert.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, nlogalert.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, nlogalert.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, nlogalert.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasNlog != nil {
		p := nlogalert.HasNlog()
		if !*i.HasNlog {
			p = nlogalert.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNlogWith) > 0 {
		with := make([]predicate.Nlog, 0, len(i.HasNlogWith))
		for _, w := range i.HasNlogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNlogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, nlogalert.HasNlogWith(with...))
	}
	if i.HasAlert != nil {
		p := nlogalert.HasAlert()
		if !*i.HasAlert {
			p = nlogalert.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAlertWith) > 0 {
		with := make([]predicate.MsgAlert, 0, len(i.HasAlertWith))
		for _, w := range i.HasAlertWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAlertWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, nlogalert.HasAlertWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNlogAlertWhereInput
	case 1:
		return predicates[0], nil
	default:
		return nlogalert.And(predicates...), nil
	}
}

// SilenceWhereInput represents a where input for filtering Silence queries.
type SilenceWhereInput struct {
	Predicates []predicate.Silence  `json:"-"`
	Not        *SilenceWhereInput   `json:"not,omitempty"`
	Or         []*SilenceWhereInput `json:"or,omitempty"`
	And        []*SilenceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "starts_at" field predicates.
	StartsAt      *time.Time  `json:"startsAt,omitempty"`
	StartsAtNEQ   *time.Time  `json:"startsAtNEQ,omitempty"`
	StartsAtIn    []time.Time `json:"startsAtIn,omitempty"`
	StartsAtNotIn []time.Time `json:"startsAtNotIn,omitempty"`
	StartsAtGT    *time.Time  `json:"startsAtGT,omitempty"`
	StartsAtGTE   *time.Time  `json:"startsAtGTE,omitempty"`
	StartsAtLT    *time.Time  `json:"startsAtLT,omitempty"`
	StartsAtLTE   *time.Time  `json:"startsAtLTE,omitempty"`

	// "ends_at" field predicates.
	EndsAt      *time.Time  `json:"endsAt,omitempty"`
	EndsAtNEQ   *time.Time  `json:"endsAtNEQ,omitempty"`
	EndsAtIn    []time.Time `json:"endsAtIn,omitempty"`
	EndsAtNotIn []time.Time `json:"endsAtNotIn,omitempty"`
	EndsAtGT    *time.Time  `json:"endsAtGT,omitempty"`
	EndsAtGTE   *time.Time  `json:"endsAtGTE,omitempty"`
	EndsAtLT    *time.Time  `json:"endsAtLT,omitempty"`
	EndsAtLTE   *time.Time  `json:"endsAtLTE,omitempty"`

	// "state" field predicates.
	State      *alert.SilenceState  `json:"state,omitempty"`
	StateNEQ   *alert.SilenceState  `json:"stateNEQ,omitempty"`
	StateIn    []alert.SilenceState `json:"stateIn,omitempty"`
	StateNotIn []alert.SilenceState `json:"stateNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SilenceWhereInput) AddPredicates(predicates ...predicate.Silence) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SilenceWhereInput filter on the SilenceQuery builder.
func (i *SilenceWhereInput) Filter(q *SilenceQuery) (*SilenceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySilenceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySilenceWhereInput is returned in case the SilenceWhereInput is empty.
var ErrEmptySilenceWhereInput = errors.New("ent: empty predicate SilenceWhereInput")

// P returns a predicate for filtering silences.
// An error is returned if the input is empty or invalid.
func (i *SilenceWhereInput) P() (predicate.Silence, error) {
	var predicates []predicate.Silence
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, silence.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Silence, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, silence.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Silence, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, silence.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, silence.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, silence.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, silence.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, silence.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, silence.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, silence.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, silence.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, silence.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, silence.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, silence.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, silence.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, silence.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, silence.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, silence.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, silence.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, silence.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, silence.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, silence.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, silence.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, silence.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, silence.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, silence.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, silence.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, silence.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, silence.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, silence.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, silence.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, silence.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, silence.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, silence.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, silence.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, silence.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, silence.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, silence.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, silence.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, silence.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, silence.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, silence.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, silence.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, silence.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, silence.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, silence.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, silence.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, silence.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, silence.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, silence.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, silence.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, silence.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.StartsAt != nil {
		predicates = append(predicates, silence.StartsAtEQ(*i.StartsAt))
	}
	if i.StartsAtNEQ != nil {
		predicates = append(predicates, silence.StartsAtNEQ(*i.StartsAtNEQ))
	}
	if len(i.StartsAtIn) > 0 {
		predicates = append(predicates, silence.StartsAtIn(i.StartsAtIn...))
	}
	if len(i.StartsAtNotIn) > 0 {
		predicates = append(predicates, silence.StartsAtNotIn(i.StartsAtNotIn...))
	}
	if i.StartsAtGT != nil {
		predicates = append(predicates, silence.StartsAtGT(*i.StartsAtGT))
	}
	if i.StartsAtGTE != nil {
		predicates = append(predicates, silence.StartsAtGTE(*i.StartsAtGTE))
	}
	if i.StartsAtLT != nil {
		predicates = append(predicates, silence.StartsAtLT(*i.StartsAtLT))
	}
	if i.StartsAtLTE != nil {
		predicates = append(predicates, silence.StartsAtLTE(*i.StartsAtLTE))
	}
	if i.EndsAt != nil {
		predicates = append(predicates, silence.EndsAtEQ(*i.EndsAt))
	}
	if i.EndsAtNEQ != nil {
		predicates = append(predicates, silence.EndsAtNEQ(*i.EndsAtNEQ))
	}
	if len(i.EndsAtIn) > 0 {
		predicates = append(predicates, silence.EndsAtIn(i.EndsAtIn...))
	}
	if len(i.EndsAtNotIn) > 0 {
		predicates = append(predicates, silence.EndsAtNotIn(i.EndsAtNotIn...))
	}
	if i.EndsAtGT != nil {
		predicates = append(predicates, silence.EndsAtGT(*i.EndsAtGT))
	}
	if i.EndsAtGTE != nil {
		predicates = append(predicates, silence.EndsAtGTE(*i.EndsAtGTE))
	}
	if i.EndsAtLT != nil {
		predicates = append(predicates, silence.EndsAtLT(*i.EndsAtLT))
	}
	if i.EndsAtLTE != nil {
		predicates = append(predicates, silence.EndsAtLTE(*i.EndsAtLTE))
	}
	if i.State != nil {
		predicates = append(predicates, silence.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, silence.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, silence.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, silence.StateNotIn(i.StateNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySilenceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return silence.And(predicates...), nil
	}
}
