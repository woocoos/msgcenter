// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/msgcenter/ent/msgchannel"
	"github.com/woocoos/msgcenter/ent/msgevent"
	"github.com/woocoos/msgcenter/ent/msgsubscriber"
	"github.com/woocoos/msgcenter/ent/msgtemplate"
	"github.com/woocoos/msgcenter/ent/msgtype"
	"github.com/woocoos/msgcenter/ent/predicate"
	"github.com/woocoos/msgcenter/ent/silence"
	"github.com/woocoos/msgcenter/pkg/alert"
	"github.com/woocoos/msgcenter/pkg/profile"
)

// MsgChannelWhereInput represents a where input for filtering MsgChannel queries.
type MsgChannelWhereInput struct {
	Predicates []predicate.MsgChannel  `json:"-"`
	Not        *MsgChannelWhereInput   `json:"not,omitempty"`
	Or         []*MsgChannelWhereInput `json:"or,omitempty"`
	And        []*MsgChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "receiver_type" field predicates.
	ReceiverType      *profile.ReceiverType  `json:"receiverType,omitempty"`
	ReceiverTypeNEQ   *profile.ReceiverType  `json:"receiverTypeNEQ,omitempty"`
	ReceiverTypeIn    []profile.ReceiverType `json:"receiverTypeIn,omitempty"`
	ReceiverTypeNotIn []profile.ReceiverType `json:"receiverTypeNotIn,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsIsNil        bool     `json:"commentsIsNil,omitempty"`
	CommentsNotNil       bool     `json:"commentsNotNil,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgChannelWhereInput) AddPredicates(predicates ...predicate.MsgChannel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgChannelWhereInput filter on the MsgChannelQuery builder.
func (i *MsgChannelWhereInput) Filter(q *MsgChannelQuery) (*MsgChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgChannelWhereInput is returned in case the MsgChannelWhereInput is empty.
var ErrEmptyMsgChannelWhereInput = errors.New("ent: empty predicate MsgChannelWhereInput")

// P returns a predicate for filtering msgchannels.
// An error is returned if the input is empty or invalid.
func (i *MsgChannelWhereInput) P() (predicate.MsgChannel, error) {
	var predicates []predicate.MsgChannel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgchannel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgChannel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgchannel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgChannel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgchannel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgchannel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgchannel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgchannel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgchannel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgchannel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgchannel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgchannel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgchannel.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgchannel.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgchannel.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgchannel.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgchannel.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgchannel.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgchannel.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgchannel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgchannel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgchannel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgchannel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgchannel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgchannel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgchannel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgchannel.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgchannel.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgchannel.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgchannel.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgchannel.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgchannel.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgchannel.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgchannel.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgchannel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgchannel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgchannel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgchannel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgchannel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgchannel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgchannel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgchannel.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgchannel.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, msgchannel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgchannel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgchannel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgchannel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgchannel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgchannel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgchannel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgchannel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgchannel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgchannel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgchannel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgchannel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgchannel.NameContainsFold(*i.NameContainsFold))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgchannel.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgchannel.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgchannel.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgchannel.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgchannel.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgchannel.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgchannel.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgchannel.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.ReceiverType != nil {
		predicates = append(predicates, msgchannel.ReceiverTypeEQ(*i.ReceiverType))
	}
	if i.ReceiverTypeNEQ != nil {
		predicates = append(predicates, msgchannel.ReceiverTypeNEQ(*i.ReceiverTypeNEQ))
	}
	if len(i.ReceiverTypeIn) > 0 {
		predicates = append(predicates, msgchannel.ReceiverTypeIn(i.ReceiverTypeIn...))
	}
	if len(i.ReceiverTypeNotIn) > 0 {
		predicates = append(predicates, msgchannel.ReceiverTypeNotIn(i.ReceiverTypeNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, msgchannel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgchannel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgchannel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgchannel.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgchannel.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgchannel.StatusNotNil())
	}
	if i.Comments != nil {
		predicates = append(predicates, msgchannel.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, msgchannel.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, msgchannel.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, msgchannel.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, msgchannel.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, msgchannel.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, msgchannel.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, msgchannel.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, msgchannel.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, msgchannel.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, msgchannel.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsIsNil {
		predicates = append(predicates, msgchannel.CommentsIsNil())
	}
	if i.CommentsNotNil {
		predicates = append(predicates, msgchannel.CommentsNotNil())
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, msgchannel.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, msgchannel.CommentsContainsFold(*i.CommentsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgchannel.And(predicates...), nil
	}
}

// MsgEventWhereInput represents a where input for filtering MsgEvent queries.
type MsgEventWhereInput struct {
	Predicates []predicate.MsgEvent  `json:"-"`
	Not        *MsgEventWhereInput   `json:"not,omitempty"`
	Or         []*MsgEventWhereInput `json:"or,omitempty"`
	And        []*MsgEventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "modes" field predicates.
	Modes             *string  `json:"modes,omitempty"`
	ModesNEQ          *string  `json:"modesNEQ,omitempty"`
	ModesIn           []string `json:"modesIn,omitempty"`
	ModesNotIn        []string `json:"modesNotIn,omitempty"`
	ModesGT           *string  `json:"modesGT,omitempty"`
	ModesGTE          *string  `json:"modesGTE,omitempty"`
	ModesLT           *string  `json:"modesLT,omitempty"`
	ModesLTE          *string  `json:"modesLTE,omitempty"`
	ModesContains     *string  `json:"modesContains,omitempty"`
	ModesHasPrefix    *string  `json:"modesHasPrefix,omitempty"`
	ModesHasSuffix    *string  `json:"modesHasSuffix,omitempty"`
	ModesEqualFold    *string  `json:"modesEqualFold,omitempty"`
	ModesContainsFold *string  `json:"modesContainsFold,omitempty"`

	// "msg_type" edge predicates.
	HasMsgType     *bool                `json:"hasMsgType,omitempty"`
	HasMsgTypeWith []*MsgTypeWhereInput `json:"hasMsgTypeWith,omitempty"`

	// "customer_template" edge predicates.
	HasCustomerTemplate     *bool                    `json:"hasCustomerTemplate,omitempty"`
	HasCustomerTemplateWith []*MsgTemplateWhereInput `json:"hasCustomerTemplateWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgEventWhereInput) AddPredicates(predicates ...predicate.MsgEvent) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgEventWhereInput filter on the MsgEventQuery builder.
func (i *MsgEventWhereInput) Filter(q *MsgEventQuery) (*MsgEventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgEventWhereInput is returned in case the MsgEventWhereInput is empty.
var ErrEmptyMsgEventWhereInput = errors.New("ent: empty predicate MsgEventWhereInput")

// P returns a predicate for filtering msgevents.
// An error is returned if the input is empty or invalid.
func (i *MsgEventWhereInput) P() (predicate.MsgEvent, error) {
	var predicates []predicate.MsgEvent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgevent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgEvent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgevent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgEvent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgevent.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgevent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgevent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgevent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgevent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgevent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgevent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgevent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgevent.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgevent.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgevent.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgevent.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgevent.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgevent.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgevent.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgevent.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgevent.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgevent.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgevent.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgevent.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgevent.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgevent.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgevent.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgevent.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgevent.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgevent.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgevent.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgevent.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgevent.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgevent.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgevent.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgevent.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgevent.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgevent.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgevent.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgevent.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgevent.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgevent.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgevent.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgevent.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgevent.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgevent.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgevent.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgevent.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgevent.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgevent.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, msgevent.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgevent.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgevent.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgevent.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgevent.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgevent.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgevent.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgevent.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgevent.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgevent.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgevent.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgevent.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgevent.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgevent.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgevent.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgevent.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgevent.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgevent.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgevent.StatusNotNil())
	}
	if i.Modes != nil {
		predicates = append(predicates, msgevent.ModesEQ(*i.Modes))
	}
	if i.ModesNEQ != nil {
		predicates = append(predicates, msgevent.ModesNEQ(*i.ModesNEQ))
	}
	if len(i.ModesIn) > 0 {
		predicates = append(predicates, msgevent.ModesIn(i.ModesIn...))
	}
	if len(i.ModesNotIn) > 0 {
		predicates = append(predicates, msgevent.ModesNotIn(i.ModesNotIn...))
	}
	if i.ModesGT != nil {
		predicates = append(predicates, msgevent.ModesGT(*i.ModesGT))
	}
	if i.ModesGTE != nil {
		predicates = append(predicates, msgevent.ModesGTE(*i.ModesGTE))
	}
	if i.ModesLT != nil {
		predicates = append(predicates, msgevent.ModesLT(*i.ModesLT))
	}
	if i.ModesLTE != nil {
		predicates = append(predicates, msgevent.ModesLTE(*i.ModesLTE))
	}
	if i.ModesContains != nil {
		predicates = append(predicates, msgevent.ModesContains(*i.ModesContains))
	}
	if i.ModesHasPrefix != nil {
		predicates = append(predicates, msgevent.ModesHasPrefix(*i.ModesHasPrefix))
	}
	if i.ModesHasSuffix != nil {
		predicates = append(predicates, msgevent.ModesHasSuffix(*i.ModesHasSuffix))
	}
	if i.ModesEqualFold != nil {
		predicates = append(predicates, msgevent.ModesEqualFold(*i.ModesEqualFold))
	}
	if i.ModesContainsFold != nil {
		predicates = append(predicates, msgevent.ModesContainsFold(*i.ModesContainsFold))
	}

	if i.HasMsgType != nil {
		p := msgevent.HasMsgType()
		if !*i.HasMsgType {
			p = msgevent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMsgTypeWith) > 0 {
		with := make([]predicate.MsgType, 0, len(i.HasMsgTypeWith))
		for _, w := range i.HasMsgTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMsgTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgevent.HasMsgTypeWith(with...))
	}
	if i.HasCustomerTemplate != nil {
		p := msgevent.HasCustomerTemplate()
		if !*i.HasCustomerTemplate {
			p = msgevent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerTemplateWith) > 0 {
		with := make([]predicate.MsgTemplate, 0, len(i.HasCustomerTemplateWith))
		for _, w := range i.HasCustomerTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgevent.HasCustomerTemplateWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgevent.And(predicates...), nil
	}
}

// MsgSubscriberWhereInput represents a where input for filtering MsgSubscriber queries.
type MsgSubscriberWhereInput struct {
	Predicates []predicate.MsgSubscriber  `json:"-"`
	Not        *MsgSubscriberWhereInput   `json:"not,omitempty"`
	Or         []*MsgSubscriberWhereInput `json:"or,omitempty"`
	And        []*MsgSubscriberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "org_role_id" field predicates.
	OrgRoleID       *int  `json:"orgRoleID,omitempty"`
	OrgRoleIDNEQ    *int  `json:"orgRoleIDNEQ,omitempty"`
	OrgRoleIDIn     []int `json:"orgRoleIDIn,omitempty"`
	OrgRoleIDNotIn  []int `json:"orgRoleIDNotIn,omitempty"`
	OrgRoleIDGT     *int  `json:"orgRoleIDGT,omitempty"`
	OrgRoleIDGTE    *int  `json:"orgRoleIDGTE,omitempty"`
	OrgRoleIDLT     *int  `json:"orgRoleIDLT,omitempty"`
	OrgRoleIDLTE    *int  `json:"orgRoleIDLTE,omitempty"`
	OrgRoleIDIsNil  bool  `json:"orgRoleIDIsNil,omitempty"`
	OrgRoleIDNotNil bool  `json:"orgRoleIDNotNil,omitempty"`

	// "exclude" field predicates.
	Exclude       *bool `json:"exclude,omitempty"`
	ExcludeNEQ    *bool `json:"excludeNEQ,omitempty"`
	ExcludeIsNil  bool  `json:"excludeIsNil,omitempty"`
	ExcludeNotNil bool  `json:"excludeNotNil,omitempty"`

	// "msg_type" edge predicates.
	HasMsgType     *bool                `json:"hasMsgType,omitempty"`
	HasMsgTypeWith []*MsgTypeWhereInput `json:"hasMsgTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgSubscriberWhereInput) AddPredicates(predicates ...predicate.MsgSubscriber) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgSubscriberWhereInput filter on the MsgSubscriberQuery builder.
func (i *MsgSubscriberWhereInput) Filter(q *MsgSubscriberQuery) (*MsgSubscriberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgSubscriberWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgSubscriberWhereInput is returned in case the MsgSubscriberWhereInput is empty.
var ErrEmptyMsgSubscriberWhereInput = errors.New("ent: empty predicate MsgSubscriberWhereInput")

// P returns a predicate for filtering msgsubscribers.
// An error is returned if the input is empty or invalid.
func (i *MsgSubscriberWhereInput) P() (predicate.MsgSubscriber, error) {
	var predicates []predicate.MsgSubscriber
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgsubscriber.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgSubscriber, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgsubscriber.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgSubscriber, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgsubscriber.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgsubscriber.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgsubscriber.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgsubscriber.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgsubscriber.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgsubscriber.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgsubscriber.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgsubscriber.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgsubscriber.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgsubscriber.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgsubscriber.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgsubscriber.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgsubscriber.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgsubscriber.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgsubscriber.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgsubscriber.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgsubscriber.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgsubscriber.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgsubscriber.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgsubscriber.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgsubscriber.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgsubscriber.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgsubscriber.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgsubscriber.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, msgsubscriber.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, msgsubscriber.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, msgsubscriber.UserIDNotNil())
	}
	if i.OrgRoleID != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDEQ(*i.OrgRoleID))
	}
	if i.OrgRoleIDNEQ != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNEQ(*i.OrgRoleIDNEQ))
	}
	if len(i.OrgRoleIDIn) > 0 {
		predicates = append(predicates, msgsubscriber.OrgRoleIDIn(i.OrgRoleIDIn...))
	}
	if len(i.OrgRoleIDNotIn) > 0 {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNotIn(i.OrgRoleIDNotIn...))
	}
	if i.OrgRoleIDGT != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDGT(*i.OrgRoleIDGT))
	}
	if i.OrgRoleIDGTE != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDGTE(*i.OrgRoleIDGTE))
	}
	if i.OrgRoleIDLT != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDLT(*i.OrgRoleIDLT))
	}
	if i.OrgRoleIDLTE != nil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDLTE(*i.OrgRoleIDLTE))
	}
	if i.OrgRoleIDIsNil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDIsNil())
	}
	if i.OrgRoleIDNotNil {
		predicates = append(predicates, msgsubscriber.OrgRoleIDNotNil())
	}
	if i.Exclude != nil {
		predicates = append(predicates, msgsubscriber.ExcludeEQ(*i.Exclude))
	}
	if i.ExcludeNEQ != nil {
		predicates = append(predicates, msgsubscriber.ExcludeNEQ(*i.ExcludeNEQ))
	}
	if i.ExcludeIsNil {
		predicates = append(predicates, msgsubscriber.ExcludeIsNil())
	}
	if i.ExcludeNotNil {
		predicates = append(predicates, msgsubscriber.ExcludeNotNil())
	}

	if i.HasMsgType != nil {
		p := msgsubscriber.HasMsgType()
		if !*i.HasMsgType {
			p = msgsubscriber.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMsgTypeWith) > 0 {
		with := make([]predicate.MsgType, 0, len(i.HasMsgTypeWith))
		for _, w := range i.HasMsgTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMsgTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgsubscriber.HasMsgTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgSubscriberWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgsubscriber.And(predicates...), nil
	}
}

// MsgTemplateWhereInput represents a where input for filtering MsgTemplate queries.
type MsgTemplateWhereInput struct {
	Predicates []predicate.MsgTemplate  `json:"-"`
	Not        *MsgTemplateWhereInput   `json:"not,omitempty"`
	Or         []*MsgTemplateWhereInput `json:"or,omitempty"`
	And        []*MsgTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "msg_type_id" field predicates.
	MsgTypeID      *int  `json:"msgTypeID,omitempty"`
	MsgTypeIDNEQ   *int  `json:"msgTypeIDNEQ,omitempty"`
	MsgTypeIDIn    []int `json:"msgTypeIDIn,omitempty"`
	MsgTypeIDNotIn []int `json:"msgTypeIDNotIn,omitempty"`
	MsgTypeIDGT    *int  `json:"msgTypeIDGT,omitempty"`
	MsgTypeIDGTE   *int  `json:"msgTypeIDGTE,omitempty"`
	MsgTypeIDLT    *int  `json:"msgTypeIDLT,omitempty"`
	MsgTypeIDLTE   *int  `json:"msgTypeIDLTE,omitempty"`

	// "msg_event_id" field predicates.
	MsgEventID      *int  `json:"msgEventID,omitempty"`
	MsgEventIDNEQ   *int  `json:"msgEventIDNEQ,omitempty"`
	MsgEventIDIn    []int `json:"msgEventIDIn,omitempty"`
	MsgEventIDNotIn []int `json:"msgEventIDNotIn,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "receiver_type" field predicates.
	ReceiverType      *profile.ReceiverType  `json:"receiverType,omitempty"`
	ReceiverTypeNEQ   *profile.ReceiverType  `json:"receiverTypeNEQ,omitempty"`
	ReceiverTypeIn    []profile.ReceiverType `json:"receiverTypeIn,omitempty"`
	ReceiverTypeNotIn []profile.ReceiverType `json:"receiverTypeNotIn,omitempty"`

	// "format" field predicates.
	Format      *msgtemplate.Format  `json:"format,omitempty"`
	FormatNEQ   *msgtemplate.Format  `json:"formatNEQ,omitempty"`
	FormatIn    []msgtemplate.Format `json:"formatIn,omitempty"`
	FormatNotIn []msgtemplate.Format `json:"formatNotIn,omitempty"`

	// "subject" field predicates.
	Subject             *string  `json:"subject,omitempty"`
	SubjectNEQ          *string  `json:"subjectNEQ,omitempty"`
	SubjectIn           []string `json:"subjectIn,omitempty"`
	SubjectNotIn        []string `json:"subjectNotIn,omitempty"`
	SubjectGT           *string  `json:"subjectGT,omitempty"`
	SubjectGTE          *string  `json:"subjectGTE,omitempty"`
	SubjectLT           *string  `json:"subjectLT,omitempty"`
	SubjectLTE          *string  `json:"subjectLTE,omitempty"`
	SubjectContains     *string  `json:"subjectContains,omitempty"`
	SubjectHasPrefix    *string  `json:"subjectHasPrefix,omitempty"`
	SubjectHasSuffix    *string  `json:"subjectHasSuffix,omitempty"`
	SubjectIsNil        bool     `json:"subjectIsNil,omitempty"`
	SubjectNotNil       bool     `json:"subjectNotNil,omitempty"`
	SubjectEqualFold    *string  `json:"subjectEqualFold,omitempty"`
	SubjectContainsFold *string  `json:"subjectContainsFold,omitempty"`

	// "from" field predicates.
	From             *string  `json:"from,omitempty"`
	FromNEQ          *string  `json:"fromNEQ,omitempty"`
	FromIn           []string `json:"fromIn,omitempty"`
	FromNotIn        []string `json:"fromNotIn,omitempty"`
	FromGT           *string  `json:"fromGT,omitempty"`
	FromGTE          *string  `json:"fromGTE,omitempty"`
	FromLT           *string  `json:"fromLT,omitempty"`
	FromLTE          *string  `json:"fromLTE,omitempty"`
	FromContains     *string  `json:"fromContains,omitempty"`
	FromHasPrefix    *string  `json:"fromHasPrefix,omitempty"`
	FromHasSuffix    *string  `json:"fromHasSuffix,omitempty"`
	FromIsNil        bool     `json:"fromIsNil,omitempty"`
	FromNotNil       bool     `json:"fromNotNil,omitempty"`
	FromEqualFold    *string  `json:"fromEqualFold,omitempty"`
	FromContainsFold *string  `json:"fromContainsFold,omitempty"`

	// "to" field predicates.
	To             *string  `json:"to,omitempty"`
	ToNEQ          *string  `json:"toNEQ,omitempty"`
	ToIn           []string `json:"toIn,omitempty"`
	ToNotIn        []string `json:"toNotIn,omitempty"`
	ToGT           *string  `json:"toGT,omitempty"`
	ToGTE          *string  `json:"toGTE,omitempty"`
	ToLT           *string  `json:"toLT,omitempty"`
	ToLTE          *string  `json:"toLTE,omitempty"`
	ToContains     *string  `json:"toContains,omitempty"`
	ToHasPrefix    *string  `json:"toHasPrefix,omitempty"`
	ToHasSuffix    *string  `json:"toHasSuffix,omitempty"`
	ToIsNil        bool     `json:"toIsNil,omitempty"`
	ToNotNil       bool     `json:"toNotNil,omitempty"`
	ToEqualFold    *string  `json:"toEqualFold,omitempty"`
	ToContainsFold *string  `json:"toContainsFold,omitempty"`

	// "cc" field predicates.
	Cc             *string  `json:"cc,omitempty"`
	CcNEQ          *string  `json:"ccNEQ,omitempty"`
	CcIn           []string `json:"ccIn,omitempty"`
	CcNotIn        []string `json:"ccNotIn,omitempty"`
	CcGT           *string  `json:"ccGT,omitempty"`
	CcGTE          *string  `json:"ccGTE,omitempty"`
	CcLT           *string  `json:"ccLT,omitempty"`
	CcLTE          *string  `json:"ccLTE,omitempty"`
	CcContains     *string  `json:"ccContains,omitempty"`
	CcHasPrefix    *string  `json:"ccHasPrefix,omitempty"`
	CcHasSuffix    *string  `json:"ccHasSuffix,omitempty"`
	CcIsNil        bool     `json:"ccIsNil,omitempty"`
	CcNotNil       bool     `json:"ccNotNil,omitempty"`
	CcEqualFold    *string  `json:"ccEqualFold,omitempty"`
	CcContainsFold *string  `json:"ccContainsFold,omitempty"`

	// "bcc" field predicates.
	Bcc             *string  `json:"bcc,omitempty"`
	BccNEQ          *string  `json:"bccNEQ,omitempty"`
	BccIn           []string `json:"bccIn,omitempty"`
	BccNotIn        []string `json:"bccNotIn,omitempty"`
	BccGT           *string  `json:"bccGT,omitempty"`
	BccGTE          *string  `json:"bccGTE,omitempty"`
	BccLT           *string  `json:"bccLT,omitempty"`
	BccLTE          *string  `json:"bccLTE,omitempty"`
	BccContains     *string  `json:"bccContains,omitempty"`
	BccHasPrefix    *string  `json:"bccHasPrefix,omitempty"`
	BccHasSuffix    *string  `json:"bccHasSuffix,omitempty"`
	BccIsNil        bool     `json:"bccIsNil,omitempty"`
	BccNotNil       bool     `json:"bccNotNil,omitempty"`
	BccEqualFold    *string  `json:"bccEqualFold,omitempty"`
	BccContainsFold *string  `json:"bccContainsFold,omitempty"`

	// "event" edge predicates.
	HasEvent     *bool                 `json:"hasEvent,omitempty"`
	HasEventWith []*MsgEventWhereInput `json:"hasEventWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgTemplateWhereInput) AddPredicates(predicates ...predicate.MsgTemplate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgTemplateWhereInput filter on the MsgTemplateQuery builder.
func (i *MsgTemplateWhereInput) Filter(q *MsgTemplateQuery) (*MsgTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgTemplateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgTemplateWhereInput is returned in case the MsgTemplateWhereInput is empty.
var ErrEmptyMsgTemplateWhereInput = errors.New("ent: empty predicate MsgTemplateWhereInput")

// P returns a predicate for filtering msgtemplates.
// An error is returned if the input is empty or invalid.
func (i *MsgTemplateWhereInput) P() (predicate.MsgTemplate, error) {
	var predicates []predicate.MsgTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgtemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgtemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgtemplate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgtemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgtemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgtemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgtemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgtemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgtemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgtemplate.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgtemplate.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgtemplate.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgtemplate.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgtemplate.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgtemplate.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgtemplate.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgtemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgtemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgtemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgtemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgtemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgtemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgtemplate.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgtemplate.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgtemplate.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgtemplate.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgtemplate.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgtemplate.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgtemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgtemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgtemplate.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgtemplate.UpdatedAtNotNil())
	}
	if i.MsgTypeID != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDEQ(*i.MsgTypeID))
	}
	if i.MsgTypeIDNEQ != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDNEQ(*i.MsgTypeIDNEQ))
	}
	if len(i.MsgTypeIDIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgTypeIDIn(i.MsgTypeIDIn...))
	}
	if len(i.MsgTypeIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgTypeIDNotIn(i.MsgTypeIDNotIn...))
	}
	if i.MsgTypeIDGT != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDGT(*i.MsgTypeIDGT))
	}
	if i.MsgTypeIDGTE != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDGTE(*i.MsgTypeIDGTE))
	}
	if i.MsgTypeIDLT != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDLT(*i.MsgTypeIDLT))
	}
	if i.MsgTypeIDLTE != nil {
		predicates = append(predicates, msgtemplate.MsgTypeIDLTE(*i.MsgTypeIDLTE))
	}
	if i.MsgEventID != nil {
		predicates = append(predicates, msgtemplate.MsgEventIDEQ(*i.MsgEventID))
	}
	if i.MsgEventIDNEQ != nil {
		predicates = append(predicates, msgtemplate.MsgEventIDNEQ(*i.MsgEventIDNEQ))
	}
	if len(i.MsgEventIDIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgEventIDIn(i.MsgEventIDIn...))
	}
	if len(i.MsgEventIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.MsgEventIDNotIn(i.MsgEventIDNotIn...))
	}
	if i.TenantID != nil {
		predicates = append(predicates, msgtemplate.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, msgtemplate.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, msgtemplate.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, msgtemplate.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, msgtemplate.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, msgtemplate.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, msgtemplate.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, msgtemplate.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, msgtemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgtemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgtemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgtemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgtemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgtemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgtemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgtemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgtemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgtemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgtemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgtemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgtemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgtemplate.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgtemplate.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgtemplate.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgtemplate.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgtemplate.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgtemplate.StatusNotNil())
	}
	if i.ReceiverType != nil {
		predicates = append(predicates, msgtemplate.ReceiverTypeEQ(*i.ReceiverType))
	}
	if i.ReceiverTypeNEQ != nil {
		predicates = append(predicates, msgtemplate.ReceiverTypeNEQ(*i.ReceiverTypeNEQ))
	}
	if len(i.ReceiverTypeIn) > 0 {
		predicates = append(predicates, msgtemplate.ReceiverTypeIn(i.ReceiverTypeIn...))
	}
	if len(i.ReceiverTypeNotIn) > 0 {
		predicates = append(predicates, msgtemplate.ReceiverTypeNotIn(i.ReceiverTypeNotIn...))
	}
	if i.Format != nil {
		predicates = append(predicates, msgtemplate.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, msgtemplate.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, msgtemplate.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, msgtemplate.FormatNotIn(i.FormatNotIn...))
	}
	if i.Subject != nil {
		predicates = append(predicates, msgtemplate.SubjectEQ(*i.Subject))
	}
	if i.SubjectNEQ != nil {
		predicates = append(predicates, msgtemplate.SubjectNEQ(*i.SubjectNEQ))
	}
	if len(i.SubjectIn) > 0 {
		predicates = append(predicates, msgtemplate.SubjectIn(i.SubjectIn...))
	}
	if len(i.SubjectNotIn) > 0 {
		predicates = append(predicates, msgtemplate.SubjectNotIn(i.SubjectNotIn...))
	}
	if i.SubjectGT != nil {
		predicates = append(predicates, msgtemplate.SubjectGT(*i.SubjectGT))
	}
	if i.SubjectGTE != nil {
		predicates = append(predicates, msgtemplate.SubjectGTE(*i.SubjectGTE))
	}
	if i.SubjectLT != nil {
		predicates = append(predicates, msgtemplate.SubjectLT(*i.SubjectLT))
	}
	if i.SubjectLTE != nil {
		predicates = append(predicates, msgtemplate.SubjectLTE(*i.SubjectLTE))
	}
	if i.SubjectContains != nil {
		predicates = append(predicates, msgtemplate.SubjectContains(*i.SubjectContains))
	}
	if i.SubjectHasPrefix != nil {
		predicates = append(predicates, msgtemplate.SubjectHasPrefix(*i.SubjectHasPrefix))
	}
	if i.SubjectHasSuffix != nil {
		predicates = append(predicates, msgtemplate.SubjectHasSuffix(*i.SubjectHasSuffix))
	}
	if i.SubjectIsNil {
		predicates = append(predicates, msgtemplate.SubjectIsNil())
	}
	if i.SubjectNotNil {
		predicates = append(predicates, msgtemplate.SubjectNotNil())
	}
	if i.SubjectEqualFold != nil {
		predicates = append(predicates, msgtemplate.SubjectEqualFold(*i.SubjectEqualFold))
	}
	if i.SubjectContainsFold != nil {
		predicates = append(predicates, msgtemplate.SubjectContainsFold(*i.SubjectContainsFold))
	}
	if i.From != nil {
		predicates = append(predicates, msgtemplate.FromEQ(*i.From))
	}
	if i.FromNEQ != nil {
		predicates = append(predicates, msgtemplate.FromNEQ(*i.FromNEQ))
	}
	if len(i.FromIn) > 0 {
		predicates = append(predicates, msgtemplate.FromIn(i.FromIn...))
	}
	if len(i.FromNotIn) > 0 {
		predicates = append(predicates, msgtemplate.FromNotIn(i.FromNotIn...))
	}
	if i.FromGT != nil {
		predicates = append(predicates, msgtemplate.FromGT(*i.FromGT))
	}
	if i.FromGTE != nil {
		predicates = append(predicates, msgtemplate.FromGTE(*i.FromGTE))
	}
	if i.FromLT != nil {
		predicates = append(predicates, msgtemplate.FromLT(*i.FromLT))
	}
	if i.FromLTE != nil {
		predicates = append(predicates, msgtemplate.FromLTE(*i.FromLTE))
	}
	if i.FromContains != nil {
		predicates = append(predicates, msgtemplate.FromContains(*i.FromContains))
	}
	if i.FromHasPrefix != nil {
		predicates = append(predicates, msgtemplate.FromHasPrefix(*i.FromHasPrefix))
	}
	if i.FromHasSuffix != nil {
		predicates = append(predicates, msgtemplate.FromHasSuffix(*i.FromHasSuffix))
	}
	if i.FromIsNil {
		predicates = append(predicates, msgtemplate.FromIsNil())
	}
	if i.FromNotNil {
		predicates = append(predicates, msgtemplate.FromNotNil())
	}
	if i.FromEqualFold != nil {
		predicates = append(predicates, msgtemplate.FromEqualFold(*i.FromEqualFold))
	}
	if i.FromContainsFold != nil {
		predicates = append(predicates, msgtemplate.FromContainsFold(*i.FromContainsFold))
	}
	if i.To != nil {
		predicates = append(predicates, msgtemplate.ToEQ(*i.To))
	}
	if i.ToNEQ != nil {
		predicates = append(predicates, msgtemplate.ToNEQ(*i.ToNEQ))
	}
	if len(i.ToIn) > 0 {
		predicates = append(predicates, msgtemplate.ToIn(i.ToIn...))
	}
	if len(i.ToNotIn) > 0 {
		predicates = append(predicates, msgtemplate.ToNotIn(i.ToNotIn...))
	}
	if i.ToGT != nil {
		predicates = append(predicates, msgtemplate.ToGT(*i.ToGT))
	}
	if i.ToGTE != nil {
		predicates = append(predicates, msgtemplate.ToGTE(*i.ToGTE))
	}
	if i.ToLT != nil {
		predicates = append(predicates, msgtemplate.ToLT(*i.ToLT))
	}
	if i.ToLTE != nil {
		predicates = append(predicates, msgtemplate.ToLTE(*i.ToLTE))
	}
	if i.ToContains != nil {
		predicates = append(predicates, msgtemplate.ToContains(*i.ToContains))
	}
	if i.ToHasPrefix != nil {
		predicates = append(predicates, msgtemplate.ToHasPrefix(*i.ToHasPrefix))
	}
	if i.ToHasSuffix != nil {
		predicates = append(predicates, msgtemplate.ToHasSuffix(*i.ToHasSuffix))
	}
	if i.ToIsNil {
		predicates = append(predicates, msgtemplate.ToIsNil())
	}
	if i.ToNotNil {
		predicates = append(predicates, msgtemplate.ToNotNil())
	}
	if i.ToEqualFold != nil {
		predicates = append(predicates, msgtemplate.ToEqualFold(*i.ToEqualFold))
	}
	if i.ToContainsFold != nil {
		predicates = append(predicates, msgtemplate.ToContainsFold(*i.ToContainsFold))
	}
	if i.Cc != nil {
		predicates = append(predicates, msgtemplate.CcEQ(*i.Cc))
	}
	if i.CcNEQ != nil {
		predicates = append(predicates, msgtemplate.CcNEQ(*i.CcNEQ))
	}
	if len(i.CcIn) > 0 {
		predicates = append(predicates, msgtemplate.CcIn(i.CcIn...))
	}
	if len(i.CcNotIn) > 0 {
		predicates = append(predicates, msgtemplate.CcNotIn(i.CcNotIn...))
	}
	if i.CcGT != nil {
		predicates = append(predicates, msgtemplate.CcGT(*i.CcGT))
	}
	if i.CcGTE != nil {
		predicates = append(predicates, msgtemplate.CcGTE(*i.CcGTE))
	}
	if i.CcLT != nil {
		predicates = append(predicates, msgtemplate.CcLT(*i.CcLT))
	}
	if i.CcLTE != nil {
		predicates = append(predicates, msgtemplate.CcLTE(*i.CcLTE))
	}
	if i.CcContains != nil {
		predicates = append(predicates, msgtemplate.CcContains(*i.CcContains))
	}
	if i.CcHasPrefix != nil {
		predicates = append(predicates, msgtemplate.CcHasPrefix(*i.CcHasPrefix))
	}
	if i.CcHasSuffix != nil {
		predicates = append(predicates, msgtemplate.CcHasSuffix(*i.CcHasSuffix))
	}
	if i.CcIsNil {
		predicates = append(predicates, msgtemplate.CcIsNil())
	}
	if i.CcNotNil {
		predicates = append(predicates, msgtemplate.CcNotNil())
	}
	if i.CcEqualFold != nil {
		predicates = append(predicates, msgtemplate.CcEqualFold(*i.CcEqualFold))
	}
	if i.CcContainsFold != nil {
		predicates = append(predicates, msgtemplate.CcContainsFold(*i.CcContainsFold))
	}
	if i.Bcc != nil {
		predicates = append(predicates, msgtemplate.BccEQ(*i.Bcc))
	}
	if i.BccNEQ != nil {
		predicates = append(predicates, msgtemplate.BccNEQ(*i.BccNEQ))
	}
	if len(i.BccIn) > 0 {
		predicates = append(predicates, msgtemplate.BccIn(i.BccIn...))
	}
	if len(i.BccNotIn) > 0 {
		predicates = append(predicates, msgtemplate.BccNotIn(i.BccNotIn...))
	}
	if i.BccGT != nil {
		predicates = append(predicates, msgtemplate.BccGT(*i.BccGT))
	}
	if i.BccGTE != nil {
		predicates = append(predicates, msgtemplate.BccGTE(*i.BccGTE))
	}
	if i.BccLT != nil {
		predicates = append(predicates, msgtemplate.BccLT(*i.BccLT))
	}
	if i.BccLTE != nil {
		predicates = append(predicates, msgtemplate.BccLTE(*i.BccLTE))
	}
	if i.BccContains != nil {
		predicates = append(predicates, msgtemplate.BccContains(*i.BccContains))
	}
	if i.BccHasPrefix != nil {
		predicates = append(predicates, msgtemplate.BccHasPrefix(*i.BccHasPrefix))
	}
	if i.BccHasSuffix != nil {
		predicates = append(predicates, msgtemplate.BccHasSuffix(*i.BccHasSuffix))
	}
	if i.BccIsNil {
		predicates = append(predicates, msgtemplate.BccIsNil())
	}
	if i.BccNotNil {
		predicates = append(predicates, msgtemplate.BccNotNil())
	}
	if i.BccEqualFold != nil {
		predicates = append(predicates, msgtemplate.BccEqualFold(*i.BccEqualFold))
	}
	if i.BccContainsFold != nil {
		predicates = append(predicates, msgtemplate.BccContainsFold(*i.BccContainsFold))
	}

	if i.HasEvent != nil {
		p := msgtemplate.HasEvent()
		if !*i.HasEvent {
			p = msgtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventWith) > 0 {
		with := make([]predicate.MsgEvent, 0, len(i.HasEventWith))
		for _, w := range i.HasEventWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtemplate.HasEventWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgTemplateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgtemplate.And(predicates...), nil
	}
}

// MsgTypeWhereInput represents a where input for filtering MsgType queries.
type MsgTypeWhereInput struct {
	Predicates []predicate.MsgType  `json:"-"`
	Not        *MsgTypeWhereInput   `json:"not,omitempty"`
	Or         []*MsgTypeWhereInput `json:"or,omitempty"`
	And        []*MsgTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID       *int  `json:"appID,omitempty"`
	AppIDNEQ    *int  `json:"appIDNEQ,omitempty"`
	AppIDIn     []int `json:"appIDIn,omitempty"`
	AppIDNotIn  []int `json:"appIDNotIn,omitempty"`
	AppIDGT     *int  `json:"appIDGT,omitempty"`
	AppIDGTE    *int  `json:"appIDGTE,omitempty"`
	AppIDLT     *int  `json:"appIDLT,omitempty"`
	AppIDLTE    *int  `json:"appIDLTE,omitempty"`
	AppIDIsNil  bool  `json:"appIDIsNil,omitempty"`
	AppIDNotNil bool  `json:"appIDNotNil,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "can_subs" field predicates.
	CanSubs       *bool `json:"canSubs,omitempty"`
	CanSubsNEQ    *bool `json:"canSubsNEQ,omitempty"`
	CanSubsIsNil  bool  `json:"canSubsIsNil,omitempty"`
	CanSubsNotNil bool  `json:"canSubsNotNil,omitempty"`

	// "can_custom" field predicates.
	CanCustom       *bool `json:"canCustom,omitempty"`
	CanCustomNEQ    *bool `json:"canCustomNEQ,omitempty"`
	CanCustomIsNil  bool  `json:"canCustomIsNil,omitempty"`
	CanCustomNotNil bool  `json:"canCustomNotNil,omitempty"`

	// "events" edge predicates.
	HasEvents     *bool                 `json:"hasEvents,omitempty"`
	HasEventsWith []*MsgEventWhereInput `json:"hasEventsWith,omitempty"`

	// "subscribers" edge predicates.
	HasSubscribers     *bool                      `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*MsgSubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MsgTypeWhereInput) AddPredicates(predicates ...predicate.MsgType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MsgTypeWhereInput filter on the MsgTypeQuery builder.
func (i *MsgTypeWhereInput) Filter(q *MsgTypeQuery) (*MsgTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMsgTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMsgTypeWhereInput is returned in case the MsgTypeWhereInput is empty.
var ErrEmptyMsgTypeWhereInput = errors.New("ent: empty predicate MsgTypeWhereInput")

// P returns a predicate for filtering msgtypes.
// An error is returned if the input is empty or invalid.
func (i *MsgTypeWhereInput) P() (predicate.MsgType, error) {
	var predicates []predicate.MsgType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, msgtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MsgType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, msgtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MsgType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, msgtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, msgtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, msgtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, msgtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, msgtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, msgtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, msgtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, msgtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, msgtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, msgtype.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, msgtype.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, msgtype.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, msgtype.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, msgtype.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, msgtype.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, msgtype.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, msgtype.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, msgtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, msgtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, msgtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, msgtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, msgtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, msgtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, msgtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, msgtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, msgtype.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, msgtype.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, msgtype.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, msgtype.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, msgtype.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, msgtype.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, msgtype.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, msgtype.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, msgtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, msgtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, msgtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, msgtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, msgtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, msgtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, msgtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, msgtype.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, msgtype.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, msgtype.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, msgtype.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, msgtype.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, msgtype.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, msgtype.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, msgtype.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, msgtype.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, msgtype.AppIDLTE(*i.AppIDLTE))
	}
	if i.AppIDIsNil {
		predicates = append(predicates, msgtype.AppIDIsNil())
	}
	if i.AppIDNotNil {
		predicates = append(predicates, msgtype.AppIDNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, msgtype.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, msgtype.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, msgtype.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, msgtype.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, msgtype.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, msgtype.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, msgtype.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, msgtype.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, msgtype.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, msgtype.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, msgtype.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, msgtype.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, msgtype.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, msgtype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, msgtype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, msgtype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, msgtype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, msgtype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, msgtype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, msgtype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, msgtype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, msgtype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, msgtype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, msgtype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, msgtype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, msgtype.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, msgtype.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, msgtype.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, msgtype.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, msgtype.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, msgtype.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, msgtype.StatusNotNil())
	}
	if i.CanSubs != nil {
		predicates = append(predicates, msgtype.CanSubsEQ(*i.CanSubs))
	}
	if i.CanSubsNEQ != nil {
		predicates = append(predicates, msgtype.CanSubsNEQ(*i.CanSubsNEQ))
	}
	if i.CanSubsIsNil {
		predicates = append(predicates, msgtype.CanSubsIsNil())
	}
	if i.CanSubsNotNil {
		predicates = append(predicates, msgtype.CanSubsNotNil())
	}
	if i.CanCustom != nil {
		predicates = append(predicates, msgtype.CanCustomEQ(*i.CanCustom))
	}
	if i.CanCustomNEQ != nil {
		predicates = append(predicates, msgtype.CanCustomNEQ(*i.CanCustomNEQ))
	}
	if i.CanCustomIsNil {
		predicates = append(predicates, msgtype.CanCustomIsNil())
	}
	if i.CanCustomNotNil {
		predicates = append(predicates, msgtype.CanCustomNotNil())
	}

	if i.HasEvents != nil {
		p := msgtype.HasEvents()
		if !*i.HasEvents {
			p = msgtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEventsWith) > 0 {
		with := make([]predicate.MsgEvent, 0, len(i.HasEventsWith))
		for _, w := range i.HasEventsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEventsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtype.HasEventsWith(with...))
	}
	if i.HasSubscribers != nil {
		p := msgtype.HasSubscribers()
		if !*i.HasSubscribers {
			p = msgtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscribersWith) > 0 {
		with := make([]predicate.MsgSubscriber, 0, len(i.HasSubscribersWith))
		for _, w := range i.HasSubscribersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscribersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, msgtype.HasSubscribersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMsgTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return msgtype.And(predicates...), nil
	}
}

// SilenceWhereInput represents a where input for filtering Silence queries.
type SilenceWhereInput struct {
	Predicates []predicate.Silence  `json:"-"`
	Not        *SilenceWhereInput   `json:"not,omitempty"`
	Or         []*SilenceWhereInput `json:"or,omitempty"`
	And        []*SilenceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "starts_at" field predicates.
	StartsAt      *time.Time  `json:"startsAt,omitempty"`
	StartsAtNEQ   *time.Time  `json:"startsAtNEQ,omitempty"`
	StartsAtIn    []time.Time `json:"startsAtIn,omitempty"`
	StartsAtNotIn []time.Time `json:"startsAtNotIn,omitempty"`
	StartsAtGT    *time.Time  `json:"startsAtGT,omitempty"`
	StartsAtGTE   *time.Time  `json:"startsAtGTE,omitempty"`
	StartsAtLT    *time.Time  `json:"startsAtLT,omitempty"`
	StartsAtLTE   *time.Time  `json:"startsAtLTE,omitempty"`

	// "ends_at" field predicates.
	EndsAt      *time.Time  `json:"endsAt,omitempty"`
	EndsAtNEQ   *time.Time  `json:"endsAtNEQ,omitempty"`
	EndsAtIn    []time.Time `json:"endsAtIn,omitempty"`
	EndsAtNotIn []time.Time `json:"endsAtNotIn,omitempty"`
	EndsAtGT    *time.Time  `json:"endsAtGT,omitempty"`
	EndsAtGTE   *time.Time  `json:"endsAtGTE,omitempty"`
	EndsAtLT    *time.Time  `json:"endsAtLT,omitempty"`
	EndsAtLTE   *time.Time  `json:"endsAtLTE,omitempty"`

	// "state" field predicates.
	State      *alert.SilenceState  `json:"state,omitempty"`
	StateNEQ   *alert.SilenceState  `json:"stateNEQ,omitempty"`
	StateIn    []alert.SilenceState `json:"stateIn,omitempty"`
	StateNotIn []alert.SilenceState `json:"stateNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SilenceWhereInput) AddPredicates(predicates ...predicate.Silence) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SilenceWhereInput filter on the SilenceQuery builder.
func (i *SilenceWhereInput) Filter(q *SilenceQuery) (*SilenceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySilenceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySilenceWhereInput is returned in case the SilenceWhereInput is empty.
var ErrEmptySilenceWhereInput = errors.New("ent: empty predicate SilenceWhereInput")

// P returns a predicate for filtering silences.
// An error is returned if the input is empty or invalid.
func (i *SilenceWhereInput) P() (predicate.Silence, error) {
	var predicates []predicate.Silence
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, silence.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Silence, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, silence.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Silence, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, silence.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, silence.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, silence.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, silence.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, silence.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, silence.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, silence.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, silence.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, silence.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, silence.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, silence.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, silence.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, silence.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, silence.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, silence.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, silence.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, silence.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, silence.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, silence.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, silence.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, silence.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, silence.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, silence.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, silence.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, silence.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, silence.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, silence.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, silence.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, silence.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, silence.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, silence.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, silence.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, silence.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, silence.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, silence.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, silence.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, silence.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, silence.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, silence.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, silence.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, silence.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, silence.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, silence.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, silence.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, silence.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, silence.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, silence.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, silence.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, silence.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.StartsAt != nil {
		predicates = append(predicates, silence.StartsAtEQ(*i.StartsAt))
	}
	if i.StartsAtNEQ != nil {
		predicates = append(predicates, silence.StartsAtNEQ(*i.StartsAtNEQ))
	}
	if len(i.StartsAtIn) > 0 {
		predicates = append(predicates, silence.StartsAtIn(i.StartsAtIn...))
	}
	if len(i.StartsAtNotIn) > 0 {
		predicates = append(predicates, silence.StartsAtNotIn(i.StartsAtNotIn...))
	}
	if i.StartsAtGT != nil {
		predicates = append(predicates, silence.StartsAtGT(*i.StartsAtGT))
	}
	if i.StartsAtGTE != nil {
		predicates = append(predicates, silence.StartsAtGTE(*i.StartsAtGTE))
	}
	if i.StartsAtLT != nil {
		predicates = append(predicates, silence.StartsAtLT(*i.StartsAtLT))
	}
	if i.StartsAtLTE != nil {
		predicates = append(predicates, silence.StartsAtLTE(*i.StartsAtLTE))
	}
	if i.EndsAt != nil {
		predicates = append(predicates, silence.EndsAtEQ(*i.EndsAt))
	}
	if i.EndsAtNEQ != nil {
		predicates = append(predicates, silence.EndsAtNEQ(*i.EndsAtNEQ))
	}
	if len(i.EndsAtIn) > 0 {
		predicates = append(predicates, silence.EndsAtIn(i.EndsAtIn...))
	}
	if len(i.EndsAtNotIn) > 0 {
		predicates = append(predicates, silence.EndsAtNotIn(i.EndsAtNotIn...))
	}
	if i.EndsAtGT != nil {
		predicates = append(predicates, silence.EndsAtGT(*i.EndsAtGT))
	}
	if i.EndsAtGTE != nil {
		predicates = append(predicates, silence.EndsAtGTE(*i.EndsAtGTE))
	}
	if i.EndsAtLT != nil {
		predicates = append(predicates, silence.EndsAtLT(*i.EndsAtLT))
	}
	if i.EndsAtLTE != nil {
		predicates = append(predicates, silence.EndsAtLTE(*i.EndsAtLTE))
	}
	if i.State != nil {
		predicates = append(predicates, silence.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, silence.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, silence.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, silence.StateNotIn(i.StateNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySilenceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return silence.And(predicates...), nil
	}
}
