// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/woocoos/msgcenter/ent"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Route() RouteResolver
	RouteInput() RouteInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	EmailConfig struct {
		AuthIdentity func(childComplexity int) int
		AuthPassword func(childComplexity int) int
		AuthSecret   func(childComplexity int) int
		AuthType     func(childComplexity int) int
		AuthUsername func(childComplexity int) int
		Headers      func(childComplexity int) int
		SmartHost    func(childComplexity int) int
	}

	Matcher struct {
		Name  func(childComplexity int) int
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	MsgChannel struct {
		Comments     func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Receiver     func(childComplexity int) int
		ReceiverType func(childComplexity int) int
		Status       func(childComplexity int) int
		TenantID     func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		UpdatedBy    func(childComplexity int) int
	}

	MsgEvent struct {
		Comments         func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		CustomerTemplate func(childComplexity int) int
		ID               func(childComplexity int) int
		Modes            func(childComplexity int) int
		MsgType          func(childComplexity int) int
		MsgTypeID        func(childComplexity int) int
		Name             func(childComplexity int) int
		Route            func(childComplexity int) int
		Status           func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		UpdatedBy        func(childComplexity int) int
	}

	MsgSubscriber struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Exclude   func(childComplexity int) int
		ID        func(childComplexity int) int
		MsgType   func(childComplexity int) int
		MsgTypeID func(childComplexity int) int
		TenantID  func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UpdatedBy func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	MsgTemplate struct {
		Attachments  func(childComplexity int) int
		Bcc          func(childComplexity int) int
		Body         func(childComplexity int) int
		Cc           func(childComplexity int) int
		Comments     func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		Event        func(childComplexity int) int
		Format       func(childComplexity int) int
		From         func(childComplexity int) int
		ID           func(childComplexity int) int
		MsgEventID   func(childComplexity int) int
		MsgTypeID    func(childComplexity int) int
		Name         func(childComplexity int) int
		ReceiverType func(childComplexity int) int
		Status       func(childComplexity int) int
		Subject      func(childComplexity int) int
		TenantID     func(childComplexity int) int
		To           func(childComplexity int) int
		Tpl          func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		UpdatedBy    func(childComplexity int) int
	}

	MsgType struct {
		AppID       func(childComplexity int) int
		CanCustom   func(childComplexity int) int
		CanSubs     func(childComplexity int) int
		Category    func(childComplexity int) int
		Comments    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Events      func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Status      func(childComplexity int) int
		Subscribers func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	Mutation struct {
		CreateMsgChannel func(childComplexity int, input ent.CreateMsgChannelInput) int
		CreateMsgEvent   func(childComplexity int, input ent.CreateMsgEventInput) int
		CreateMsgType    func(childComplexity int, input ent.CreateMsgTypeInput) int
		DeleteMsgChannel func(childComplexity int, id int) int
		DeleteMsgEvent   func(childComplexity int, id int) int
		DeleteMsgType    func(childComplexity int, id int) int
		EnableMsgChannel func(childComplexity int, id int) int
		EnableMsgEvent   func(childComplexity int, id int) int
		UpdateMsgChannel func(childComplexity int, id int, input ent.UpdateMsgChannelInput) int
		UpdateMsgEvent   func(childComplexity int, id int, input ent.UpdateMsgEventInput) int
		UpdateMsgType    func(childComplexity int, id int, input ent.UpdateMsgTypeInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Node  func(childComplexity int, id string) int
		Nodes func(childComplexity int, ids []string) int
	}

	Receiver struct {
		EmailConfigs func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	Route struct {
		ActiveTimeIntervals func(childComplexity int) int
		Continue            func(childComplexity int) int
		GroupBy             func(childComplexity int) int
		GroupInterval       func(childComplexity int) int
		GroupWait           func(childComplexity int) int
		Matchers            func(childComplexity int) int
		MuteTimeIntervals   func(childComplexity int) int
		Receiver            func(childComplexity int) int
		RepeatInterval      func(childComplexity int) int
		Routes              func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "EmailConfig.authIdentity":
		if e.complexity.EmailConfig.AuthIdentity == nil {
			break
		}

		return e.complexity.EmailConfig.AuthIdentity(childComplexity), true

	case "EmailConfig.authPassword":
		if e.complexity.EmailConfig.AuthPassword == nil {
			break
		}

		return e.complexity.EmailConfig.AuthPassword(childComplexity), true

	case "EmailConfig.authSecret":
		if e.complexity.EmailConfig.AuthSecret == nil {
			break
		}

		return e.complexity.EmailConfig.AuthSecret(childComplexity), true

	case "EmailConfig.authType":
		if e.complexity.EmailConfig.AuthType == nil {
			break
		}

		return e.complexity.EmailConfig.AuthType(childComplexity), true

	case "EmailConfig.authUsername":
		if e.complexity.EmailConfig.AuthUsername == nil {
			break
		}

		return e.complexity.EmailConfig.AuthUsername(childComplexity), true

	case "EmailConfig.headers":
		if e.complexity.EmailConfig.Headers == nil {
			break
		}

		return e.complexity.EmailConfig.Headers(childComplexity), true

	case "EmailConfig.smartHost":
		if e.complexity.EmailConfig.SmartHost == nil {
			break
		}

		return e.complexity.EmailConfig.SmartHost(childComplexity), true

	case "Matcher.name":
		if e.complexity.Matcher.Name == nil {
			break
		}

		return e.complexity.Matcher.Name(childComplexity), true

	case "Matcher.type":
		if e.complexity.Matcher.Type == nil {
			break
		}

		return e.complexity.Matcher.Type(childComplexity), true

	case "Matcher.value":
		if e.complexity.Matcher.Value == nil {
			break
		}

		return e.complexity.Matcher.Value(childComplexity), true

	case "MsgChannel.comments":
		if e.complexity.MsgChannel.Comments == nil {
			break
		}

		return e.complexity.MsgChannel.Comments(childComplexity), true

	case "MsgChannel.createdAt":
		if e.complexity.MsgChannel.CreatedAt == nil {
			break
		}

		return e.complexity.MsgChannel.CreatedAt(childComplexity), true

	case "MsgChannel.createdBy":
		if e.complexity.MsgChannel.CreatedBy == nil {
			break
		}

		return e.complexity.MsgChannel.CreatedBy(childComplexity), true

	case "MsgChannel.id":
		if e.complexity.MsgChannel.ID == nil {
			break
		}

		return e.complexity.MsgChannel.ID(childComplexity), true

	case "MsgChannel.name":
		if e.complexity.MsgChannel.Name == nil {
			break
		}

		return e.complexity.MsgChannel.Name(childComplexity), true

	case "MsgChannel.receiver":
		if e.complexity.MsgChannel.Receiver == nil {
			break
		}

		return e.complexity.MsgChannel.Receiver(childComplexity), true

	case "MsgChannel.receiverType":
		if e.complexity.MsgChannel.ReceiverType == nil {
			break
		}

		return e.complexity.MsgChannel.ReceiverType(childComplexity), true

	case "MsgChannel.status":
		if e.complexity.MsgChannel.Status == nil {
			break
		}

		return e.complexity.MsgChannel.Status(childComplexity), true

	case "MsgChannel.tenantID":
		if e.complexity.MsgChannel.TenantID == nil {
			break
		}

		return e.complexity.MsgChannel.TenantID(childComplexity), true

	case "MsgChannel.updatedAt":
		if e.complexity.MsgChannel.UpdatedAt == nil {
			break
		}

		return e.complexity.MsgChannel.UpdatedAt(childComplexity), true

	case "MsgChannel.updatedBy":
		if e.complexity.MsgChannel.UpdatedBy == nil {
			break
		}

		return e.complexity.MsgChannel.UpdatedBy(childComplexity), true

	case "MsgEvent.comments":
		if e.complexity.MsgEvent.Comments == nil {
			break
		}

		return e.complexity.MsgEvent.Comments(childComplexity), true

	case "MsgEvent.createdAt":
		if e.complexity.MsgEvent.CreatedAt == nil {
			break
		}

		return e.complexity.MsgEvent.CreatedAt(childComplexity), true

	case "MsgEvent.createdBy":
		if e.complexity.MsgEvent.CreatedBy == nil {
			break
		}

		return e.complexity.MsgEvent.CreatedBy(childComplexity), true

	case "MsgEvent.customerTemplate":
		if e.complexity.MsgEvent.CustomerTemplate == nil {
			break
		}

		return e.complexity.MsgEvent.CustomerTemplate(childComplexity), true

	case "MsgEvent.id":
		if e.complexity.MsgEvent.ID == nil {
			break
		}

		return e.complexity.MsgEvent.ID(childComplexity), true

	case "MsgEvent.modes":
		if e.complexity.MsgEvent.Modes == nil {
			break
		}

		return e.complexity.MsgEvent.Modes(childComplexity), true

	case "MsgEvent.msgType":
		if e.complexity.MsgEvent.MsgType == nil {
			break
		}

		return e.complexity.MsgEvent.MsgType(childComplexity), true

	case "MsgEvent.msgTypeID":
		if e.complexity.MsgEvent.MsgTypeID == nil {
			break
		}

		return e.complexity.MsgEvent.MsgTypeID(childComplexity), true

	case "MsgEvent.name":
		if e.complexity.MsgEvent.Name == nil {
			break
		}

		return e.complexity.MsgEvent.Name(childComplexity), true

	case "MsgEvent.route":
		if e.complexity.MsgEvent.Route == nil {
			break
		}

		return e.complexity.MsgEvent.Route(childComplexity), true

	case "MsgEvent.status":
		if e.complexity.MsgEvent.Status == nil {
			break
		}

		return e.complexity.MsgEvent.Status(childComplexity), true

	case "MsgEvent.updatedAt":
		if e.complexity.MsgEvent.UpdatedAt == nil {
			break
		}

		return e.complexity.MsgEvent.UpdatedAt(childComplexity), true

	case "MsgEvent.updatedBy":
		if e.complexity.MsgEvent.UpdatedBy == nil {
			break
		}

		return e.complexity.MsgEvent.UpdatedBy(childComplexity), true

	case "MsgSubscriber.createdAt":
		if e.complexity.MsgSubscriber.CreatedAt == nil {
			break
		}

		return e.complexity.MsgSubscriber.CreatedAt(childComplexity), true

	case "MsgSubscriber.createdBy":
		if e.complexity.MsgSubscriber.CreatedBy == nil {
			break
		}

		return e.complexity.MsgSubscriber.CreatedBy(childComplexity), true

	case "MsgSubscriber.exclude":
		if e.complexity.MsgSubscriber.Exclude == nil {
			break
		}

		return e.complexity.MsgSubscriber.Exclude(childComplexity), true

	case "MsgSubscriber.id":
		if e.complexity.MsgSubscriber.ID == nil {
			break
		}

		return e.complexity.MsgSubscriber.ID(childComplexity), true

	case "MsgSubscriber.msgType":
		if e.complexity.MsgSubscriber.MsgType == nil {
			break
		}

		return e.complexity.MsgSubscriber.MsgType(childComplexity), true

	case "MsgSubscriber.msgTypeID":
		if e.complexity.MsgSubscriber.MsgTypeID == nil {
			break
		}

		return e.complexity.MsgSubscriber.MsgTypeID(childComplexity), true

	case "MsgSubscriber.tenantID":
		if e.complexity.MsgSubscriber.TenantID == nil {
			break
		}

		return e.complexity.MsgSubscriber.TenantID(childComplexity), true

	case "MsgSubscriber.updatedAt":
		if e.complexity.MsgSubscriber.UpdatedAt == nil {
			break
		}

		return e.complexity.MsgSubscriber.UpdatedAt(childComplexity), true

	case "MsgSubscriber.updatedBy":
		if e.complexity.MsgSubscriber.UpdatedBy == nil {
			break
		}

		return e.complexity.MsgSubscriber.UpdatedBy(childComplexity), true

	case "MsgSubscriber.userID":
		if e.complexity.MsgSubscriber.UserID == nil {
			break
		}

		return e.complexity.MsgSubscriber.UserID(childComplexity), true

	case "MsgTemplate.attachments":
		if e.complexity.MsgTemplate.Attachments == nil {
			break
		}

		return e.complexity.MsgTemplate.Attachments(childComplexity), true

	case "MsgTemplate.bcc":
		if e.complexity.MsgTemplate.Bcc == nil {
			break
		}

		return e.complexity.MsgTemplate.Bcc(childComplexity), true

	case "MsgTemplate.body":
		if e.complexity.MsgTemplate.Body == nil {
			break
		}

		return e.complexity.MsgTemplate.Body(childComplexity), true

	case "MsgTemplate.cc":
		if e.complexity.MsgTemplate.Cc == nil {
			break
		}

		return e.complexity.MsgTemplate.Cc(childComplexity), true

	case "MsgTemplate.comments":
		if e.complexity.MsgTemplate.Comments == nil {
			break
		}

		return e.complexity.MsgTemplate.Comments(childComplexity), true

	case "MsgTemplate.createdAt":
		if e.complexity.MsgTemplate.CreatedAt == nil {
			break
		}

		return e.complexity.MsgTemplate.CreatedAt(childComplexity), true

	case "MsgTemplate.createdBy":
		if e.complexity.MsgTemplate.CreatedBy == nil {
			break
		}

		return e.complexity.MsgTemplate.CreatedBy(childComplexity), true

	case "MsgTemplate.event":
		if e.complexity.MsgTemplate.Event == nil {
			break
		}

		return e.complexity.MsgTemplate.Event(childComplexity), true

	case "MsgTemplate.format":
		if e.complexity.MsgTemplate.Format == nil {
			break
		}

		return e.complexity.MsgTemplate.Format(childComplexity), true

	case "MsgTemplate.from":
		if e.complexity.MsgTemplate.From == nil {
			break
		}

		return e.complexity.MsgTemplate.From(childComplexity), true

	case "MsgTemplate.id":
		if e.complexity.MsgTemplate.ID == nil {
			break
		}

		return e.complexity.MsgTemplate.ID(childComplexity), true

	case "MsgTemplate.msgEventID":
		if e.complexity.MsgTemplate.MsgEventID == nil {
			break
		}

		return e.complexity.MsgTemplate.MsgEventID(childComplexity), true

	case "MsgTemplate.msgTypeID":
		if e.complexity.MsgTemplate.MsgTypeID == nil {
			break
		}

		return e.complexity.MsgTemplate.MsgTypeID(childComplexity), true

	case "MsgTemplate.name":
		if e.complexity.MsgTemplate.Name == nil {
			break
		}

		return e.complexity.MsgTemplate.Name(childComplexity), true

	case "MsgTemplate.receiverType":
		if e.complexity.MsgTemplate.ReceiverType == nil {
			break
		}

		return e.complexity.MsgTemplate.ReceiverType(childComplexity), true

	case "MsgTemplate.status":
		if e.complexity.MsgTemplate.Status == nil {
			break
		}

		return e.complexity.MsgTemplate.Status(childComplexity), true

	case "MsgTemplate.subject":
		if e.complexity.MsgTemplate.Subject == nil {
			break
		}

		return e.complexity.MsgTemplate.Subject(childComplexity), true

	case "MsgTemplate.tenantID":
		if e.complexity.MsgTemplate.TenantID == nil {
			break
		}

		return e.complexity.MsgTemplate.TenantID(childComplexity), true

	case "MsgTemplate.to":
		if e.complexity.MsgTemplate.To == nil {
			break
		}

		return e.complexity.MsgTemplate.To(childComplexity), true

	case "MsgTemplate.tpl":
		if e.complexity.MsgTemplate.Tpl == nil {
			break
		}

		return e.complexity.MsgTemplate.Tpl(childComplexity), true

	case "MsgTemplate.updatedAt":
		if e.complexity.MsgTemplate.UpdatedAt == nil {
			break
		}

		return e.complexity.MsgTemplate.UpdatedAt(childComplexity), true

	case "MsgTemplate.updatedBy":
		if e.complexity.MsgTemplate.UpdatedBy == nil {
			break
		}

		return e.complexity.MsgTemplate.UpdatedBy(childComplexity), true

	case "MsgType.appID":
		if e.complexity.MsgType.AppID == nil {
			break
		}

		return e.complexity.MsgType.AppID(childComplexity), true

	case "MsgType.canCustom":
		if e.complexity.MsgType.CanCustom == nil {
			break
		}

		return e.complexity.MsgType.CanCustom(childComplexity), true

	case "MsgType.canSubs":
		if e.complexity.MsgType.CanSubs == nil {
			break
		}

		return e.complexity.MsgType.CanSubs(childComplexity), true

	case "MsgType.category":
		if e.complexity.MsgType.Category == nil {
			break
		}

		return e.complexity.MsgType.Category(childComplexity), true

	case "MsgType.comments":
		if e.complexity.MsgType.Comments == nil {
			break
		}

		return e.complexity.MsgType.Comments(childComplexity), true

	case "MsgType.createdAt":
		if e.complexity.MsgType.CreatedAt == nil {
			break
		}

		return e.complexity.MsgType.CreatedAt(childComplexity), true

	case "MsgType.createdBy":
		if e.complexity.MsgType.CreatedBy == nil {
			break
		}

		return e.complexity.MsgType.CreatedBy(childComplexity), true

	case "MsgType.events":
		if e.complexity.MsgType.Events == nil {
			break
		}

		return e.complexity.MsgType.Events(childComplexity), true

	case "MsgType.id":
		if e.complexity.MsgType.ID == nil {
			break
		}

		return e.complexity.MsgType.ID(childComplexity), true

	case "MsgType.name":
		if e.complexity.MsgType.Name == nil {
			break
		}

		return e.complexity.MsgType.Name(childComplexity), true

	case "MsgType.status":
		if e.complexity.MsgType.Status == nil {
			break
		}

		return e.complexity.MsgType.Status(childComplexity), true

	case "MsgType.subscribers":
		if e.complexity.MsgType.Subscribers == nil {
			break
		}

		return e.complexity.MsgType.Subscribers(childComplexity), true

	case "MsgType.updatedAt":
		if e.complexity.MsgType.UpdatedAt == nil {
			break
		}

		return e.complexity.MsgType.UpdatedAt(childComplexity), true

	case "MsgType.updatedBy":
		if e.complexity.MsgType.UpdatedBy == nil {
			break
		}

		return e.complexity.MsgType.UpdatedBy(childComplexity), true

	case "Mutation.createMsgChannel":
		if e.complexity.Mutation.CreateMsgChannel == nil {
			break
		}

		args, err := ec.field_Mutation_createMsgChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMsgChannel(childComplexity, args["input"].(ent.CreateMsgChannelInput)), true

	case "Mutation.createMsgEvent":
		if e.complexity.Mutation.CreateMsgEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createMsgEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMsgEvent(childComplexity, args["input"].(ent.CreateMsgEventInput)), true

	case "Mutation.createMsgType":
		if e.complexity.Mutation.CreateMsgType == nil {
			break
		}

		args, err := ec.field_Mutation_createMsgType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMsgType(childComplexity, args["input"].(ent.CreateMsgTypeInput)), true

	case "Mutation.deleteMsgChannel":
		if e.complexity.Mutation.DeleteMsgChannel == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMsgChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMsgChannel(childComplexity, args["id"].(int)), true

	case "Mutation.deleteMsgEvent":
		if e.complexity.Mutation.DeleteMsgEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMsgEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMsgEvent(childComplexity, args["id"].(int)), true

	case "Mutation.deleteMsgType":
		if e.complexity.Mutation.DeleteMsgType == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMsgType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMsgType(childComplexity, args["id"].(int)), true

	case "Mutation.enableMsgChannel":
		if e.complexity.Mutation.EnableMsgChannel == nil {
			break
		}

		args, err := ec.field_Mutation_enableMsgChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableMsgChannel(childComplexity, args["id"].(int)), true

	case "Mutation.enableMsgEvent":
		if e.complexity.Mutation.EnableMsgEvent == nil {
			break
		}

		args, err := ec.field_Mutation_enableMsgEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnableMsgEvent(childComplexity, args["id"].(int)), true

	case "Mutation.updateMsgChannel":
		if e.complexity.Mutation.UpdateMsgChannel == nil {
			break
		}

		args, err := ec.field_Mutation_updateMsgChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMsgChannel(childComplexity, args["id"].(int), args["input"].(ent.UpdateMsgChannelInput)), true

	case "Mutation.updateMsgEvent":
		if e.complexity.Mutation.UpdateMsgEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateMsgEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMsgEvent(childComplexity, args["id"].(int), args["input"].(ent.UpdateMsgEventInput)), true

	case "Mutation.updateMsgType":
		if e.complexity.Mutation.UpdateMsgType == nil {
			break
		}

		args, err := ec.field_Mutation_updateMsgType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMsgType(childComplexity, args["id"].(int), args["input"].(ent.UpdateMsgTypeInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Receiver.emailConfigs":
		if e.complexity.Receiver.EmailConfigs == nil {
			break
		}

		return e.complexity.Receiver.EmailConfigs(childComplexity), true

	case "Receiver.name":
		if e.complexity.Receiver.Name == nil {
			break
		}

		return e.complexity.Receiver.Name(childComplexity), true

	case "Route.activeTimeIntervals":
		if e.complexity.Route.ActiveTimeIntervals == nil {
			break
		}

		return e.complexity.Route.ActiveTimeIntervals(childComplexity), true

	case "Route.continue":
		if e.complexity.Route.Continue == nil {
			break
		}

		return e.complexity.Route.Continue(childComplexity), true

	case "Route.groupBy":
		if e.complexity.Route.GroupBy == nil {
			break
		}

		return e.complexity.Route.GroupBy(childComplexity), true

	case "Route.GroupInterval":
		if e.complexity.Route.GroupInterval == nil {
			break
		}

		return e.complexity.Route.GroupInterval(childComplexity), true

	case "Route.groupWait":
		if e.complexity.Route.GroupWait == nil {
			break
		}

		return e.complexity.Route.GroupWait(childComplexity), true

	case "Route.matchers":
		if e.complexity.Route.Matchers == nil {
			break
		}

		return e.complexity.Route.Matchers(childComplexity), true

	case "Route.muteTimeIntervals":
		if e.complexity.Route.MuteTimeIntervals == nil {
			break
		}

		return e.complexity.Route.MuteTimeIntervals(childComplexity), true

	case "Route.receiver":
		if e.complexity.Route.Receiver == nil {
			break
		}

		return e.complexity.Route.Receiver(childComplexity), true

	case "Route.repeatInterval":
		if e.complexity.Route.RepeatInterval == nil {
			break
		}

		return e.complexity.Route.RepeatInterval(childComplexity), true

	case "Route.routes":
		if e.complexity.Route.Routes == nil {
			break
		}

		return e.complexity.Route.Routes(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateMsgChannelInput,
		ec.unmarshalInputCreateMsgEventInput,
		ec.unmarshalInputCreateMsgSubscriberInput,
		ec.unmarshalInputCreateMsgTemplateInput,
		ec.unmarshalInputCreateMsgTypeInput,
		ec.unmarshalInputEmailConfigInput,
		ec.unmarshalInputMatcherInput,
		ec.unmarshalInputMsgChannelOrder,
		ec.unmarshalInputMsgChannelWhereInput,
		ec.unmarshalInputMsgEventOrder,
		ec.unmarshalInputMsgEventWhereInput,
		ec.unmarshalInputMsgSubscriberOrder,
		ec.unmarshalInputMsgSubscriberWhereInput,
		ec.unmarshalInputMsgTemplateOrder,
		ec.unmarshalInputMsgTemplateWhereInput,
		ec.unmarshalInputMsgTypeOrder,
		ec.unmarshalInputMsgTypeWhereInput,
		ec.unmarshalInputReceiverInput,
		ec.unmarshalInputRouteInput,
		ec.unmarshalInputUpdateMsgChannelInput,
		ec.unmarshalInputUpdateMsgEventInput,
		ec.unmarshalInputUpdateMsgSubscriberInput,
		ec.unmarshalInputUpdateMsgTemplateInput,
		ec.unmarshalInputUpdateMsgTypeInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateMsgChannelInput is used for create MsgChannel object.
Input was generated by ent.
"""
input CreateMsgChannelInput {
  """消息通道名称"""
  name: String!
  """组织ID"""
  tenantID: Int!
  """支持的消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgChannelReceiverType!
  """通道配置Json格式"""
  receiver: ReceiverInput!
  """备注"""
  comments: String
}
"""
CreateMsgEventInput is used for create MsgEvent object.
Input was generated by ent.
"""
input CreateMsgEventInput {
  """消息事件名称,应用内唯一"""
  name: String!
  """备注"""
  comments: String
  """消息路由配置"""
  route: RouteInput
  """根据route配置对应的以,分隔的mode列表"""
  modes: String!
  msgTypeID: ID!
}
"""
CreateMsgSubscriberInput is used for create MsgSubscriber object.
Input was generated by ent.
"""
input CreateMsgSubscriberInput {
  """组织ID"""
  tenantID: Int!
  """用户ID"""
  userID: Int!
  """是否排除"""
  exclude: Boolean
  msgTypeID: ID!
}
"""
CreateMsgTemplateInput is used for create MsgTemplate object.
Input was generated by ent.
"""
input CreateMsgTemplateInput {
  """应用消息类型ID"""
  msgTypeID: Int!
  """组织ID"""
  tenantID: Int!
  """消息模板名称"""
  name: String!
  """状态"""
  status: MsgTemplateSimpleStatus
  """消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgTemplateReceiverType!
  """消息类型:文本,网页,需要结合mod确定支持的格式"""
  format: MsgTemplateFormat!
  """标题"""
  subject: String
  """发件人"""
  from: String
  """收件人"""
  to: String
  """抄送"""
  cc: String
  """密送"""
  bcc: String
  """消息体"""
  body: String
  """模板地址"""
  tpl: String
  """附件地址,多个附件用逗号分隔"""
  attachments: String
  """备注"""
  comments: String
  eventID: ID!
}
"""
CreateMsgTypeInput is used for create MsgType object.
Input was generated by ent.
"""
input CreateMsgTypeInput {
  """应用ID"""
  appID: Int
  """消息类型分类"""
  category: String!
  """消息类型名称,应用内唯一"""
  name: String!
  """状态"""
  status: MsgTypeSimpleStatus
  """备注"""
  comments: String
  """是否可订阅"""
  canSubs: Boolean
  """是否可定制"""
  canCustom: Boolean
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""An object with an Global ID,for using in Noder interface."""
scalar GID
type MsgChannel implements Node {
  id: ID!
  createdBy: Int!
  createdAt: Time!
  updatedBy: Int
  updatedAt: Time
  """消息通道名称"""
  name: String!
  """组织ID"""
  tenantID: Int!
  """支持的消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgChannelReceiverType!
  """状态"""
  status: MsgChannelSimpleStatus
  """通道配置Json格式"""
  receiver: Receiver!
  """备注"""
  comments: String
}
"""Ordering options for MsgChannel connections"""
input MsgChannelOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order MsgChannels."""
  field: MsgChannelOrderField!
}
"""Properties by which MsgChannel connections can be ordered."""
enum MsgChannelOrderField {
  createdAt
}
"""MsgChannelReceiverType is enum for the field receiver_type"""
enum MsgChannelReceiverType @goModel(model: "github.com/woocoos/msgcenter/pkg/profile.ReceiverType") {
  email
  webhook
}
"""MsgChannelSimpleStatus is enum for the field status"""
enum MsgChannelSimpleStatus @goModel(model: "github.com/woocoos/entco/schemax/typex.SimpleStatus") {
  active
  inactive
  processing
}
"""
MsgChannelWhereInput is used for filtering MsgChannel objects.
Input was generated by ent.
"""
input MsgChannelWhereInput {
  not: MsgChannelWhereInput
  and: [MsgChannelWhereInput!]
  or: [MsgChannelWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_by field predicates"""
  createdBy: Int
  createdByNEQ: Int
  createdByIn: [Int!]
  createdByNotIn: [Int!]
  createdByGT: Int
  createdByGTE: Int
  createdByLT: Int
  createdByLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_by field predicates"""
  updatedBy: Int
  updatedByNEQ: Int
  updatedByIn: [Int!]
  updatedByNotIn: [Int!]
  updatedByGT: Int
  updatedByGTE: Int
  updatedByLT: Int
  updatedByLTE: Int
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """tenant_id field predicates"""
  tenantID: Int
  tenantIDNEQ: Int
  tenantIDIn: [Int!]
  tenantIDNotIn: [Int!]
  tenantIDGT: Int
  tenantIDGTE: Int
  tenantIDLT: Int
  tenantIDLTE: Int
  """receiver_type field predicates"""
  receiverType: MsgChannelReceiverType
  receiverTypeNEQ: MsgChannelReceiverType
  receiverTypeIn: [MsgChannelReceiverType!]
  receiverTypeNotIn: [MsgChannelReceiverType!]
  """status field predicates"""
  status: MsgChannelSimpleStatus
  statusNEQ: MsgChannelSimpleStatus
  statusIn: [MsgChannelSimpleStatus!]
  statusNotIn: [MsgChannelSimpleStatus!]
  statusIsNil: Boolean
  statusNotNil: Boolean
  """comments field predicates"""
  comments: String
  commentsNEQ: String
  commentsIn: [String!]
  commentsNotIn: [String!]
  commentsGT: String
  commentsGTE: String
  commentsLT: String
  commentsLTE: String
  commentsContains: String
  commentsHasPrefix: String
  commentsHasSuffix: String
  commentsIsNil: Boolean
  commentsNotNil: Boolean
  commentsEqualFold: String
  commentsContainsFold: String
}
type MsgEvent implements Node {
  id: ID!
  createdBy: Int!
  createdAt: Time!
  updatedBy: Int
  updatedAt: Time
  """消息类型ID"""
  msgTypeID: ID!
  """消息事件名称,应用内唯一"""
  name: String!
  """状态"""
  status: MsgEventSimpleStatus
  """备注"""
  comments: String
  """消息路由配置"""
  route: Route
  """根据route配置对应的以,分隔的mode列表"""
  modes: String!
  """消息类型"""
  msgType: MsgType!
  """自定义的消息模板"""
  customerTemplate: [MsgTemplate!]
}
"""Ordering options for MsgEvent connections"""
input MsgEventOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order MsgEvents."""
  field: MsgEventOrderField!
}
"""Properties by which MsgEvent connections can be ordered."""
enum MsgEventOrderField {
  createdAt
}
"""MsgEventSimpleStatus is enum for the field status"""
enum MsgEventSimpleStatus @goModel(model: "github.com/woocoos/entco/schemax/typex.SimpleStatus") {
  active
  inactive
  processing
}
"""
MsgEventWhereInput is used for filtering MsgEvent objects.
Input was generated by ent.
"""
input MsgEventWhereInput {
  not: MsgEventWhereInput
  and: [MsgEventWhereInput!]
  or: [MsgEventWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_by field predicates"""
  createdBy: Int
  createdByNEQ: Int
  createdByIn: [Int!]
  createdByNotIn: [Int!]
  createdByGT: Int
  createdByGTE: Int
  createdByLT: Int
  createdByLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_by field predicates"""
  updatedBy: Int
  updatedByNEQ: Int
  updatedByIn: [Int!]
  updatedByNotIn: [Int!]
  updatedByGT: Int
  updatedByGTE: Int
  updatedByLT: Int
  updatedByLTE: Int
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """msg_type_id field predicates"""
  msgTypeID: ID
  msgTypeIDNEQ: ID
  msgTypeIDIn: [ID!]
  msgTypeIDNotIn: [ID!]
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """status field predicates"""
  status: MsgEventSimpleStatus
  statusNEQ: MsgEventSimpleStatus
  statusIn: [MsgEventSimpleStatus!]
  statusNotIn: [MsgEventSimpleStatus!]
  statusIsNil: Boolean
  statusNotNil: Boolean
  """modes field predicates"""
  modes: String
  modesNEQ: String
  modesIn: [String!]
  modesNotIn: [String!]
  modesGT: String
  modesGTE: String
  modesLT: String
  modesLTE: String
  modesContains: String
  modesHasPrefix: String
  modesHasSuffix: String
  modesEqualFold: String
  modesContainsFold: String
  """msg_type edge predicates"""
  hasMsgType: Boolean
  hasMsgTypeWith: [MsgTypeWhereInput!]
  """customer_template edge predicates"""
  hasCustomerTemplate: Boolean
  hasCustomerTemplateWith: [MsgTemplateWhereInput!]
}
type MsgSubscriber implements Node {
  id: ID!
  createdBy: Int!
  createdAt: Time!
  updatedBy: Int
  updatedAt: Time
  """应用消息类型ID"""
  msgTypeID: ID!
  """组织ID"""
  tenantID: Int!
  """用户ID"""
  userID: Int!
  """是否排除"""
  exclude: Boolean
  msgType: MsgType!
}
"""Ordering options for MsgSubscriber connections"""
input MsgSubscriberOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order MsgSubscribers."""
  field: MsgSubscriberOrderField!
}
"""Properties by which MsgSubscriber connections can be ordered."""
enum MsgSubscriberOrderField {
  createdAt
}
"""
MsgSubscriberWhereInput is used for filtering MsgSubscriber objects.
Input was generated by ent.
"""
input MsgSubscriberWhereInput {
  not: MsgSubscriberWhereInput
  and: [MsgSubscriberWhereInput!]
  or: [MsgSubscriberWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_by field predicates"""
  createdBy: Int
  createdByNEQ: Int
  createdByIn: [Int!]
  createdByNotIn: [Int!]
  createdByGT: Int
  createdByGTE: Int
  createdByLT: Int
  createdByLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_by field predicates"""
  updatedBy: Int
  updatedByNEQ: Int
  updatedByIn: [Int!]
  updatedByNotIn: [Int!]
  updatedByGT: Int
  updatedByGTE: Int
  updatedByLT: Int
  updatedByLTE: Int
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """msg_type_id field predicates"""
  msgTypeID: ID
  msgTypeIDNEQ: ID
  msgTypeIDIn: [ID!]
  msgTypeIDNotIn: [ID!]
  """tenant_id field predicates"""
  tenantID: Int
  tenantIDNEQ: Int
  tenantIDIn: [Int!]
  tenantIDNotIn: [Int!]
  tenantIDGT: Int
  tenantIDGTE: Int
  tenantIDLT: Int
  tenantIDLTE: Int
  """user_id field predicates"""
  userID: Int
  userIDNEQ: Int
  userIDIn: [Int!]
  userIDNotIn: [Int!]
  userIDGT: Int
  userIDGTE: Int
  userIDLT: Int
  userIDLTE: Int
  """exclude field predicates"""
  exclude: Boolean
  excludeNEQ: Boolean
  excludeIsNil: Boolean
  excludeNotNil: Boolean
  """msg_type edge predicates"""
  hasMsgType: Boolean
  hasMsgTypeWith: [MsgTypeWhereInput!]
}
type MsgTemplate implements Node {
  id: ID!
  createdBy: Int!
  createdAt: Time!
  updatedBy: Int
  updatedAt: Time
  """应用消息类型ID"""
  msgTypeID: Int!
  """消息事件ID"""
  msgEventID: ID!
  """组织ID"""
  tenantID: Int!
  """消息模板名称"""
  name: String!
  """状态"""
  status: MsgTemplateSimpleStatus
  """消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgTemplateReceiverType!
  """消息类型:文本,网页,需要结合mod确定支持的格式"""
  format: MsgTemplateFormat!
  """标题"""
  subject: String
  """发件人"""
  from: String
  """收件人"""
  to: String
  """抄送"""
  cc: String
  """密送"""
  bcc: String
  """消息体"""
  body: String
  """模板地址"""
  tpl: String
  """附件地址,多个附件用逗号分隔"""
  attachments: String
  """备注"""
  comments: String
  event: MsgEvent!
}
"""MsgTemplateFormat is enum for the field format"""
enum MsgTemplateFormat @goModel(model: "github.com/woocoos/msgcenter/ent/msgtemplate.Format") {
  txt
  html
}
"""Ordering options for MsgTemplate connections"""
input MsgTemplateOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order MsgTemplates."""
  field: MsgTemplateOrderField!
}
"""Properties by which MsgTemplate connections can be ordered."""
enum MsgTemplateOrderField {
  createdAt
}
"""MsgTemplateReceiverType is enum for the field receiver_type"""
enum MsgTemplateReceiverType @goModel(model: "github.com/woocoos/msgcenter/pkg/profile.ReceiverType") {
  email
  webhook
}
"""MsgTemplateSimpleStatus is enum for the field status"""
enum MsgTemplateSimpleStatus @goModel(model: "github.com/woocoos/entco/schemax/typex.SimpleStatus") {
  active
  inactive
  processing
}
"""
MsgTemplateWhereInput is used for filtering MsgTemplate objects.
Input was generated by ent.
"""
input MsgTemplateWhereInput {
  not: MsgTemplateWhereInput
  and: [MsgTemplateWhereInput!]
  or: [MsgTemplateWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_by field predicates"""
  createdBy: Int
  createdByNEQ: Int
  createdByIn: [Int!]
  createdByNotIn: [Int!]
  createdByGT: Int
  createdByGTE: Int
  createdByLT: Int
  createdByLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_by field predicates"""
  updatedBy: Int
  updatedByNEQ: Int
  updatedByIn: [Int!]
  updatedByNotIn: [Int!]
  updatedByGT: Int
  updatedByGTE: Int
  updatedByLT: Int
  updatedByLTE: Int
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """msg_type_id field predicates"""
  msgTypeID: Int
  msgTypeIDNEQ: Int
  msgTypeIDIn: [Int!]
  msgTypeIDNotIn: [Int!]
  msgTypeIDGT: Int
  msgTypeIDGTE: Int
  msgTypeIDLT: Int
  msgTypeIDLTE: Int
  """msg_event_id field predicates"""
  msgEventID: ID
  msgEventIDNEQ: ID
  msgEventIDIn: [ID!]
  msgEventIDNotIn: [ID!]
  """tenant_id field predicates"""
  tenantID: Int
  tenantIDNEQ: Int
  tenantIDIn: [Int!]
  tenantIDNotIn: [Int!]
  tenantIDGT: Int
  tenantIDGTE: Int
  tenantIDLT: Int
  tenantIDLTE: Int
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """status field predicates"""
  status: MsgTemplateSimpleStatus
  statusNEQ: MsgTemplateSimpleStatus
  statusIn: [MsgTemplateSimpleStatus!]
  statusNotIn: [MsgTemplateSimpleStatus!]
  statusIsNil: Boolean
  statusNotNil: Boolean
  """receiver_type field predicates"""
  receiverType: MsgTemplateReceiverType
  receiverTypeNEQ: MsgTemplateReceiverType
  receiverTypeIn: [MsgTemplateReceiverType!]
  receiverTypeNotIn: [MsgTemplateReceiverType!]
  """format field predicates"""
  format: MsgTemplateFormat
  formatNEQ: MsgTemplateFormat
  formatIn: [MsgTemplateFormat!]
  formatNotIn: [MsgTemplateFormat!]
  """subject field predicates"""
  subject: String
  subjectNEQ: String
  subjectIn: [String!]
  subjectNotIn: [String!]
  subjectGT: String
  subjectGTE: String
  subjectLT: String
  subjectLTE: String
  subjectContains: String
  subjectHasPrefix: String
  subjectHasSuffix: String
  subjectIsNil: Boolean
  subjectNotNil: Boolean
  subjectEqualFold: String
  subjectContainsFold: String
  """from field predicates"""
  from: String
  fromNEQ: String
  fromIn: [String!]
  fromNotIn: [String!]
  fromGT: String
  fromGTE: String
  fromLT: String
  fromLTE: String
  fromContains: String
  fromHasPrefix: String
  fromHasSuffix: String
  fromIsNil: Boolean
  fromNotNil: Boolean
  fromEqualFold: String
  fromContainsFold: String
  """to field predicates"""
  to: String
  toNEQ: String
  toIn: [String!]
  toNotIn: [String!]
  toGT: String
  toGTE: String
  toLT: String
  toLTE: String
  toContains: String
  toHasPrefix: String
  toHasSuffix: String
  toIsNil: Boolean
  toNotNil: Boolean
  toEqualFold: String
  toContainsFold: String
  """cc field predicates"""
  cc: String
  ccNEQ: String
  ccIn: [String!]
  ccNotIn: [String!]
  ccGT: String
  ccGTE: String
  ccLT: String
  ccLTE: String
  ccContains: String
  ccHasPrefix: String
  ccHasSuffix: String
  ccIsNil: Boolean
  ccNotNil: Boolean
  ccEqualFold: String
  ccContainsFold: String
  """bcc field predicates"""
  bcc: String
  bccNEQ: String
  bccIn: [String!]
  bccNotIn: [String!]
  bccGT: String
  bccGTE: String
  bccLT: String
  bccLTE: String
  bccContains: String
  bccHasPrefix: String
  bccHasSuffix: String
  bccIsNil: Boolean
  bccNotNil: Boolean
  bccEqualFold: String
  bccContainsFold: String
  """event edge predicates"""
  hasEvent: Boolean
  hasEventWith: [MsgEventWhereInput!]
}
type MsgType implements Node {
  id: ID!
  createdBy: Int!
  createdAt: Time!
  updatedBy: Int
  updatedAt: Time
  """应用ID"""
  appID: Int
  """消息类型分类"""
  category: String!
  """消息类型名称,应用内唯一"""
  name: String!
  """状态"""
  status: MsgTypeSimpleStatus
  """备注"""
  comments: String
  """是否可订阅"""
  canSubs: Boolean
  """是否可定制"""
  canCustom: Boolean
  """消息事件"""
  events: [MsgEvent!]
  """订阅者"""
  subscribers: [MsgSubscriber!]
}
"""Ordering options for MsgType connections"""
input MsgTypeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order MsgTypes."""
  field: MsgTypeOrderField!
}
"""Properties by which MsgType connections can be ordered."""
enum MsgTypeOrderField {
  createdAt
}
"""MsgTypeSimpleStatus is enum for the field status"""
enum MsgTypeSimpleStatus @goModel(model: "github.com/woocoos/entco/schemax/typex.SimpleStatus") {
  active
  inactive
  processing
}
"""
MsgTypeWhereInput is used for filtering MsgType objects.
Input was generated by ent.
"""
input MsgTypeWhereInput {
  not: MsgTypeWhereInput
  and: [MsgTypeWhereInput!]
  or: [MsgTypeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_by field predicates"""
  createdBy: Int
  createdByNEQ: Int
  createdByIn: [Int!]
  createdByNotIn: [Int!]
  createdByGT: Int
  createdByGTE: Int
  createdByLT: Int
  createdByLTE: Int
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_by field predicates"""
  updatedBy: Int
  updatedByNEQ: Int
  updatedByIn: [Int!]
  updatedByNotIn: [Int!]
  updatedByGT: Int
  updatedByGTE: Int
  updatedByLT: Int
  updatedByLTE: Int
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  updatedAtIsNil: Boolean
  updatedAtNotNil: Boolean
  """app_id field predicates"""
  appID: Int
  appIDNEQ: Int
  appIDIn: [Int!]
  appIDNotIn: [Int!]
  appIDGT: Int
  appIDGTE: Int
  appIDLT: Int
  appIDLTE: Int
  appIDIsNil: Boolean
  appIDNotNil: Boolean
  """category field predicates"""
  category: String
  categoryNEQ: String
  categoryIn: [String!]
  categoryNotIn: [String!]
  categoryGT: String
  categoryGTE: String
  categoryLT: String
  categoryLTE: String
  categoryContains: String
  categoryHasPrefix: String
  categoryHasSuffix: String
  categoryEqualFold: String
  categoryContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """status field predicates"""
  status: MsgTypeSimpleStatus
  statusNEQ: MsgTypeSimpleStatus
  statusIn: [MsgTypeSimpleStatus!]
  statusNotIn: [MsgTypeSimpleStatus!]
  statusIsNil: Boolean
  statusNotNil: Boolean
  """can_subs field predicates"""
  canSubs: Boolean
  canSubsNEQ: Boolean
  canSubsIsNil: Boolean
  canSubsNotNil: Boolean
  """can_custom field predicates"""
  canCustom: Boolean
  canCustomNEQ: Boolean
  canCustomIsNil: Boolean
  canCustomNotNil: Boolean
  """events edge predicates"""
  hasEvents: Boolean
  hasEventsWith: [MsgEventWhereInput!]
  """subscribers edge predicates"""
  hasSubscribers: Boolean
  hasSubscribersWith: [MsgSubscriberWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/woocoos/msgcenter/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: GID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [GID!]!
  ): [Node]!
}
"""The builtin Time type"""
scalar Time
"""
UpdateMsgChannelInput is used for update MsgChannel object.
Input was generated by ent.
"""
input UpdateMsgChannelInput {
  """消息通道名称"""
  name: String
  """组织ID"""
  tenantID: Int
  """支持的消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgChannelReceiverType
  """状态"""
  status: MsgChannelSimpleStatus
  clearStatus: Boolean
  """通道配置Json格式"""
  receiver: ReceiverInput
  """备注"""
  comments: String
  clearComments: Boolean
}
"""
UpdateMsgEventInput is used for update MsgEvent object.
Input was generated by ent.
"""
input UpdateMsgEventInput {
  """消息事件名称,应用内唯一"""
  name: String
  """状态"""
  status: MsgEventSimpleStatus
  clearStatus: Boolean
  """备注"""
  comments: String
  clearComments: Boolean
  """消息路由配置"""
  route: RouteInput
  clearRoute: Boolean
  """根据route配置对应的以,分隔的mode列表"""
  modes: String
  msgTypeID: ID
}
"""
UpdateMsgSubscriberInput is used for update MsgSubscriber object.
Input was generated by ent.
"""
input UpdateMsgSubscriberInput {
  """组织ID"""
  tenantID: Int
  """用户ID"""
  userID: Int
  """是否排除"""
  exclude: Boolean
  clearExclude: Boolean
  msgTypeID: ID
}
"""
UpdateMsgTemplateInput is used for update MsgTemplate object.
Input was generated by ent.
"""
input UpdateMsgTemplateInput {
  """应用消息类型ID"""
  msgTypeID: Int
  """组织ID"""
  tenantID: Int
  """消息模板名称"""
  name: String
  """状态"""
  status: MsgTemplateSimpleStatus
  clearStatus: Boolean
  """消息模式:站内信,app推送,邮件,短信,微信等"""
  receiverType: MsgTemplateReceiverType
  """消息类型:文本,网页,需要结合mod确定支持的格式"""
  format: MsgTemplateFormat
  """标题"""
  subject: String
  clearSubject: Boolean
  """发件人"""
  from: String
  clearFrom: Boolean
  """收件人"""
  to: String
  clearTo: Boolean
  """抄送"""
  cc: String
  clearCc: Boolean
  """密送"""
  bcc: String
  clearBcc: Boolean
  """消息体"""
  body: String
  clearBody: Boolean
  """模板地址"""
  tpl: String
  clearTpl: Boolean
  """附件地址,多个附件用逗号分隔"""
  attachments: String
  clearAttachments: Boolean
  """备注"""
  comments: String
  clearComments: Boolean
  eventID: ID
}
"""
UpdateMsgTypeInput is used for update MsgType object.
Input was generated by ent.
"""
input UpdateMsgTypeInput {
  """应用ID"""
  appID: Int
  clearAppID: Boolean
  """消息类型分类"""
  category: String
  """消息类型名称,应用内唯一"""
  name: String
  """状态"""
  status: MsgTypeSimpleStatus
  clearStatus: Boolean
  """备注"""
  comments: String
  clearComments: Boolean
  """是否可订阅"""
  canSubs: Boolean
  clearCanSubs: Boolean
  """是否可定制"""
  canCustom: Boolean
  clearCanCustom: Boolean
}
`, BuiltIn: false},
	{Name: "../query.graphql", Input: `scalar Duration
scalar LabelName
scalar MapString
scalar HostPort

enum MatchType {
    MatchEqual
    MatchNotEqual
    MatchRegexp
    MatchNotRegexp
}

type Route {
    receiver: String
    groupBy: [LabelName]
    matchers: [Matcher]
    muteTimeIntervals: [String!]
    activeTimeIntervals: [String!]
    continue: Boolean
    routes: [Route]
    groupWait: Duration
    GroupInterval: Duration
    repeatInterval: Duration
}

type Matcher {
    type: MatchType!
    name: String!
    value: String!
}

type Receiver {
    name: String!
    emailConfigs: [EmailConfig]
}

type EmailConfig {
    smartHost: HostPort!
    authType: String!
    authUsername: String!
    authPassword: String!
    authSecret: String!
    authIdentity: String!
    headers: MapString
}`, BuiltIn: false},
	{Name: "../mutation.graphql", Input: `type Mutation {
    # 创建消息类型
    createMsgType(input: CreateMsgTypeInput!): MsgType!
    # 更新消息类型
    updateMsgType(id: ID!,input: UpdateMsgTypeInput!): MsgType!
    # 删除消息类型
    deleteMsgType(id: ID!): Boolean!
    # 创建消息事件
    createMsgEvent(input: CreateMsgEventInput!): MsgEvent!
    # 更新消息事件
    updateMsgEvent(id:ID!,input: UpdateMsgEventInput!): MsgEvent!
    # 删除消息事件
    deleteMsgEvent(id: ID!): Boolean!
    # 启用消息事件
    enableMsgEvent(id: ID!): MsgEvent!
    # 创建消息通道
    createMsgChannel(input: CreateMsgChannelInput!): MsgChannel!
    # 更新消息通道
    updateMsgChannel(id: ID!,input: UpdateMsgChannelInput!): MsgChannel!
    # 删除消息通道
    deleteMsgChannel(id: ID!): Boolean!
    # 启用消息通道
    enableMsgChannel(id: ID!): MsgChannel!
}

input RouteInput  {
    receiver: String
    groupBy: [LabelName]
    matchers: [MatcherInput]
    muteTimeIntervals: [String!]
    activeTimeIntervals: [String!]
    continue: Boolean
    routes: [RouteInput]
    groupWait: Duration
    GroupInterval: Duration
    repeatInterval: Duration
}

input MatcherInput {
    type: MatchType!
    name: String!
    value: String!
}

input ReceiverInput {
    name: String!
    emailConfigs: [EmailConfigInput]
}

input EmailConfigInput {
    smartHost: HostPort!
    authType: String!
    authUsername: String!
    authPassword: String!
    authSecret: String!
    authIdentity: String!
    headers: MapString
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
