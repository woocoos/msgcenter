// Code generated by woco, DO NOT EDIT.

package oas

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/tsingsun/woocoo/pkg/gds"
	"github.com/tsingsun/woocoo/web/handler"
)

// RegisterGeneralHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterGeneralHandlers(router *gin.RouterGroup, si GeneralServer) {
	router.GET("/status", wrapGetStatus(si))
}

// RegisterReceiverHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterReceiverHandlers(router *gin.RouterGroup, si ReceiverServer) {
	router.GET("/receivers", wrapGetReceivers(si))
}

// RegisterSilenceHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterSilenceHandlers(router *gin.RouterGroup, si SilenceServer) {
	router.DELETE("/silence/:silenceID", wrapDeleteSilence(si))
	router.GET("/silence/:silenceID", wrapGetSilence(si))
	router.GET("/silences", wrapGetSilences(si))
	router.POST("/silences", wrapPostSilences(si))
}

// RegisterAlertHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterAlertHandlers(router *gin.RouterGroup, si AlertServer) {
	router.GET("/alerts", wrapGetAlerts(si))
	router.POST("/alerts", wrapPostAlerts(si))
}

// RegisterPushHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterPushHandlers(router *gin.RouterGroup, si PushServer) {
	router.POST("/push", wrapPostPush(si))
}

func wrapGetStatus(si GeneralServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetStatus(c)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetReceivers(si ReceiverServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetReceivers(c)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapDeleteSilence(si SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req DeleteSilenceRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeleteSilence(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapGetSilence(si SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetSilenceRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetSilence(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("A silence with the specified ID was not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetSilences(si SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetSilencesRequest
		if err := c.ShouldBindQuery(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetSilences(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapPostSilences(si SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req PostSilencesRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.PostSilences(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("A silence with the specified ID was not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetAlerts(si AlertServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		req := GetAlertsRequest{
			Active:      gds.Ptr(true),
			Silenced:    gds.Ptr(true),
			Inhibited:   gds.Ptr(true),
			Unprocessed: gds.Ptr(true),
		}
		if err := c.ShouldBindQuery(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetAlerts(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapPostAlerts(si AlertServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req PostAlertsRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.PostAlerts(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapPostPush(si PushServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req PostPushRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.PostPush(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}
