// Code generated by woco, DO NOT EDIT.

package server

import (
	"errors"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/tsingsun/woocoo/web/handler"
	"github.com/woocoos/msgcenter/api/oas"
)

// RegisterGeneralHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterGeneralHandlers(router *gin.RouterGroup, si oas.GeneralServer) {
	router.GET("/status", wrapGetStatus(si))
}

// RegisterReceiverHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterReceiverHandlers(router *gin.RouterGroup, si oas.ReceiverServer) {
	router.GET("/receivers", wrapGetReceivers(si))
}

// RegisterSilenceHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterSilenceHandlers(router *gin.RouterGroup, si oas.SilenceServer) {
	router.DELETE("/silence/:silenceID", wrapDeleteSilence(si))
	router.GET("/silence/:silenceID", wrapGetSilence(si))
	router.GET("/silences", wrapGetSilences(si))
	router.POST("/silences", wrapPostSilences(si))
}

// RegisterAlertHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterAlertHandlers(router *gin.RouterGroup, si oas.AlertServer) {
	router.GET("/alerts", wrapGetAlerts(si))
	router.POST("/alerts", wrapPostAlerts(si))
}

func wrapGetStatus(si oas.GeneralServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetStatus(c)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetReceivers(si oas.ReceiverServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		resp, err := si.GetReceivers(c)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapDeleteSilence(si oas.SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.DeleteSilenceRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeleteSilence(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapGetSilence(si oas.SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.GetSilenceRequest
		if err := c.ShouldBindUri(&req.UriParams); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetSilence(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("A silence with the specified ID was not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetSilences(si oas.SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.GetSilencesRequest
		if err := c.ShouldBind(&req.Filter); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetSilences(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapPostSilences(si oas.SilenceServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.PostSilencesRequest
		if err := c.ShouldBind(&req.PostableSilence); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.PostSilences(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		if resp == nil {
			handler.AbortWithError(c, http.StatusBadRequest, errors.New("A silence with the specified ID was not found"))
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetAlerts(si oas.AlertServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.GetAlertsRequest
		if err := c.ShouldBind(&req.Body); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetAlerts(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapPostAlerts(si oas.AlertServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req oas.PostAlertsRequest
		if err := c.ShouldBind(&req.PostableAlerts); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.PostAlerts(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}
